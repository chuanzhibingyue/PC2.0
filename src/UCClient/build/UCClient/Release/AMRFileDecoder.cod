; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\decoder\AMRFileDecoder.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GAGNPJNE@Decode?$AA@			; `string'
PUBLIC	??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@		; `string'
PUBLIC	??_R1A@?0A@EA@AMRFileDecoder@@8			; AMRFileDecoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3AMRFileDecoder@@8				; AMRFileDecoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7AMRFileDecoder@@6B@				; AMRFileDecoder::`vftable'
PUBLIC	??_R2AMRFileDecoder@@8				; AMRFileDecoder::`RTTI Base Class Array'
PUBLIC	??_R4AMRFileDecoder@@6B@			; AMRFileDecoder::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVAMRFileDecoder@@@8			; AMRFileDecoder `RTTI Type Descriptor'
EXTRN	__imp__CreateFileMappingW@24:PROC
EXTRN	__imp__GetFileSizeEx@8:PROC
EXTRN	__imp__UnmapViewOfFile@4:PROC
EXTRN	__imp__MapViewOfFile@20:PROC
;	COMDAT ??_R0?AVAMRFileDecoder@@@8
data$r	SEGMENT
??_R0?AVAMRFileDecoder@@@8 DD FLAT:??_7type_info@@6B@	; AMRFileDecoder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAMRFileDecoder@@', 00H
data$r	ENDS
;	COMDAT ??_R4AMRFileDecoder@@6B@
rdata$r	SEGMENT
??_R4AMRFileDecoder@@6B@ DD 00H				; AMRFileDecoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAMRFileDecoder@@@8
	DD	FLAT:??_R3AMRFileDecoder@@8
rdata$r	ENDS
;	COMDAT ??_R2AMRFileDecoder@@8
rdata$r	SEGMENT
??_R2AMRFileDecoder@@8 DD FLAT:??_R1A@?0A@EA@AMRFileDecoder@@8 ; AMRFileDecoder::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7AMRFileDecoder@@6B@
CONST	SEGMENT
??_7AMRFileDecoder@@6B@ DD FLAT:??_R4AMRFileDecoder@@6B@ ; AMRFileDecoder::`vftable'
	DD	FLAT:??_EAMRFileDecoder@@UAEPAXI@Z
	DD	FLAT:?SetFilePathName@AMRFileDecoder@@UAEXPB_W@Z
	DD	FLAT:?GetTimeLength@AMRFileDecoder@@UAE_KXZ
	DD	FLAT:?GetWaveFromatX@AMRFileDecoder@@UAE?AUtWAVEFORMATEX@@XZ
	DD	FLAT:?BeginDecode@AMRFileDecoder@@UAEHXZ
	DD	FLAT:?Decode@AMRFileDecoder@@UAEKAAPAD@Z
	DD	FLAT:?IsEOF@AMRFileDecoder@@UAE_NXZ
	DD	FLAT:?EndDecode@AMRFileDecoder@@UAEXXZ
	DD	FLAT:?IsVaild@AMRFileDecoder@@UAE_NXZ
	DD	FLAT:?GetDecodedMaxSize@AMRFileDecoder@@UAEKXZ
	DD	FLAT:?GetDecodedFrameMaxSize@AMRFileDecoder@@UAEKXZ
CONST	ENDS
;	COMDAT ??_R3AMRFileDecoder@@8
rdata$r	SEGMENT
??_R3AMRFileDecoder@@8 DD 00H				; AMRFileDecoder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2AMRFileDecoder@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AMRFileDecoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AMRFileDecoder@@8 DD FLAT:??_R0?AVAMRFileDecoder@@@8 ; AMRFileDecoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AMRFileDecoder@@8
rdata$r	ENDS
;	COMDAT ??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@
CONST	SEGMENT
??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@ DB '#!AMR', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GAGNPJNE@Decode?$AA@
CONST	SEGMENT
??_C@_06GAGNPJNE@Decode?$AA@ DB 'Decode', 00H		; `string'
	ORG $+2
_amrPackedSize DD 0cH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	014H
	DD	01aH
	DD	01fH
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
PUBLIC	?GetFrameCount@AMRFileDecoder@@AAEKXZ		; AMRFileDecoder::GetFrameCount
PUBLIC	?SetFilePathName@AMRFileDecoder@@UAEXPB_W@Z	; AMRFileDecoder::SetFilePathName
PUBLIC	?GetDecodedMaxSize@AMRFileDecoder@@UAEKXZ	; AMRFileDecoder::GetDecodedMaxSize
PUBLIC	?GetDecodedFrameMaxSize@AMRFileDecoder@@UAEKXZ	; AMRFileDecoder::GetDecodedFrameMaxSize
PUBLIC	?Decode@AMRFileDecoder@@UAEKAAPAD@Z		; AMRFileDecoder::Decode
PUBLIC	?IsEOF@AMRFileDecoder@@UAE_NXZ			; AMRFileDecoder::IsEOF
PUBLIC	?EndDecode@AMRFileDecoder@@UAEXXZ		; AMRFileDecoder::EndDecode
PUBLIC	?BeginDecode@AMRFileDecoder@@UAEHXZ		; AMRFileDecoder::BeginDecode
PUBLIC	?GetWaveFromatX@AMRFileDecoder@@UAE?AUtWAVEFORMATEX@@XZ ; AMRFileDecoder::GetWaveFromatX
PUBLIC	?GetTimeLength@AMRFileDecoder@@UAE_KXZ		; AMRFileDecoder::GetTimeLength
PUBLIC	?IsVaild@AMRFileDecoder@@UAE_NXZ		; AMRFileDecoder::IsVaild
PUBLIC	??1AMRFileDecoder@@UAE@XZ			; AMRFileDecoder::~AMRFileDecoder
PUBLIC	??_GAMRFileDecoder@@UAEPAXI@Z			; AMRFileDecoder::`scalar deleting destructor'
PUBLIC	??0AMRFileDecoder@@QAE@XZ			; AMRFileDecoder::AMRFileDecoder
PUBLIC	??0AMRFileDecoder@@QAE@PB_W@Z			; AMRFileDecoder::AMRFileDecoder
EXTRN	??_EAMRFileDecoder@@UAEPAXI@Z:PROC		; AMRFileDecoder::`vector deleting destructor'
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0AMRFileDecoder@@QAE@PB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AMRFileDecoder@@QAE@PB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0AMRFileDecoder@@QAE@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AMRFileDecoder@@QAE@PB_W@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1AMRFileDecoder@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1AMRFileDecoder@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??1AMRFileDecoder@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AMRFileDecoder@@UAE@XZ$0
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ??0AMRFileDecoder@@QAE@PB_W@Z
_TEXT	SEGMENT
_liFileSize$ = -28					; size = 8
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_lpszFile$ = 8						; size = 4
??0AMRFileDecoder@@QAE@PB_W@Z PROC			; AMRFileDecoder::AMRFileDecoder, COMDAT
; _this$ = ecx

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0AMRFileDecoder@@QAE@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 306  : 			: _CSTD wcslen(_First));

  0002d	8b 7d 08	 mov	 edi, DWORD PTR _lpszFile$[ebp]

; 347  : 		_Left = _Right;

  00030	33 c0		 xor	 eax, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 46   : {

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7AMRFileDecoder@@6B@
  00038	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0003f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00046	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0004d	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00054	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  0005b	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00062	c7 46 38 07 00
	00 00		 mov	 DWORD PTR [esi+56], 7

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00069	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00070	66 89 46 24	 mov	 WORD PTR [esi+36], ax

; 306  : 			: _CSTD wcslen(_First));

  00074	66 39 07	 cmp	 WORD PTR [edi], ax
  00077	75 04		 jne	 SHORT $LN51@AMRFileDec
  00079	33 c9		 xor	 ecx, ecx
  0007b	eb 14		 jmp	 SHORT $LN52@AMRFileDec
$LN51@AMRFileDec:
  0007d	8b cf		 mov	 ecx, edi
  0007f	8d 59 02	 lea	 ebx, DWORD PTR [ecx+2]
$LL53@AMRFileDec:
  00082	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00085	83 c1 02	 add	 ecx, 2
  00088	66 85 c0	 test	 ax, ax
  0008b	75 f5		 jne	 SHORT $LL53@AMRFileDec
  0008d	2b cb		 sub	 ecx, ebx
  0008f	d1 f9		 sar	 ecx, 1
$LN52@AMRFileDec:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00091	51		 push	 ecx
  00092	57		 push	 edi
  00093	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00096	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 50   :     HANDLE hFileAmr = CreateFile(lpszFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  0009b	6a 00		 push	 0
  0009d	68 80 00 00 00	 push	 128			; 00000080H
  000a2	6a 03		 push	 3
  000a4	6a 00		 push	 0
  000a6	6a 01		 push	 1
  000a8	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000ad	57		 push	 edi
  000ae	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileW@28
  000bb	8b f8		 mov	 edi, eax

; 51   :     ATLASSERT(hFileAmr);
; 52   :     if(hFileAmr == NULL)    return ;

  000bd	85 ff		 test	 edi, edi
  000bf	74 67		 je	 SHORT $LN54@AMRFileDec

; 53   : 
; 54   :     // 
; 55   :     LARGE_INTEGER liFileSize;
; 56   :     memset(&liFileSize, 0, sizeof(LARGE_INTEGER));
; 57   :     if(!GetFileSizeEx(hFileAmr, &liFileSize))

  000c1	8d 45 e4	 lea	 eax, DWORD PTR _liFileSize$[ebp]
  000c4	0f 57 c0	 xorps	 xmm0, xmm0
  000c7	50		 push	 eax
  000c8	57		 push	 edi
  000c9	66 0f d6 45 e4	 movq	 QWORD PTR _liFileSize$[ebp], xmm0
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSizeEx@8
  000d4	85 c0		 test	 eax, eax
  000d6	75 09		 jne	 SHORT $LN2@AMRFileDec

; 58   :     {
; 59   :         CloseHandle(hFileAmr);

  000d8	57		 push	 edi
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 60   :         return;

  000df	eb 47		 jmp	 SHORT $LN54@AMRFileDec
$LN2@AMRFileDec:

; 61   :     }
; 62   :     m_liFileSize = liFileSize.QuadPart;

  000e1	8b 45 e4	 mov	 eax, DWORD PTR _liFileSize$[ebp]

; 63   : 
; 64   :     // 
; 65   :     HANDLE hFileMapping = CreateFileMapping(hFileAmr, NULL, PAGE_READONLY, 0, 0, NULL);

  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	6a 00		 push	 0
  000ea	6a 02		 push	 2
  000ec	6a 00		 push	 0
  000ee	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000f1	8b 45 e8	 mov	 eax, DWORD PTR _liFileSize$[ebp+4]
  000f4	57		 push	 edi
  000f5	89 46 14	 mov	 DWORD PTR [esi+20], eax
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileMappingW@24

; 66   :     CloseHandle(hFileAmr);

  000fe	57		 push	 edi
  000ff	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseHandle@4
  00105	8b d8		 mov	 ebx, eax
  00107	ff d7		 call	 edi

; 67   :     ATLASSERT(hFileMapping);
; 68   :     if(hFileMapping == NULL) return ;

  00109	85 db		 test	 ebx, ebx
  0010b	74 1b		 je	 SHORT $LN54@AMRFileDec

; 69   : 
; 70   :     // 
; 71   :     m_pBaseAddress = (LPSTR)MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);

  0010d	6a 00		 push	 0
  0010f	6a 00		 push	 0
  00111	6a 00		 push	 0
  00113	6a 04		 push	 4
  00115	53		 push	 ebx
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapViewOfFile@20

; 72   :     CloseHandle(hFileMapping);

  0011c	53		 push	 ebx
  0011d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00120	ff d7		 call	 edi

; 73   :     ATLASSERT(m_pBaseAddress);
; 74   : 
; 75   :     // 
; 76   :     m_pCurAddress = m_pBaseAddress;

  00122	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00125	89 46 1c	 mov	 DWORD PTR [esi+28], eax
$LN54@AMRFileDec:

; 77   : }

  00128	8b c6		 mov	 eax, esi
  0012a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00131	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00134	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013b	59		 pop	 ecx
  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AMRFileDecoder@@QAE@PB_W@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 24	 add	 ecx, 36			; 00000024H
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$??0AMRFileDecoder@@QAE@PB_W@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0AMRFileDecoder@@QAE@PB_W@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0AMRFileDecoder@@QAE@PB_W@Z ENDP			; AMRFileDecoder::AMRFileDecoder
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ??0AMRFileDecoder@@QAE@XZ
_TEXT	SEGMENT
??0AMRFileDecoder@@QAE@XZ PROC				; AMRFileDecoder::AMRFileDecoder, COMDAT
; _this$ = ecx

; 36   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7AMRFileDecoder@@6B@
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00006	33 c0		 xor	 eax, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 36   : {

  00008	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00016	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0001d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00024	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  0002b	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00032	c7 41 38 07 00
	00 00		 mov	 DWORD PTR [ecx+56], 7

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00039	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00040	66 89 41 24	 mov	 WORD PTR [ecx+36], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 37   : }

  00044	8b c1		 mov	 eax, ecx
  00046	c3		 ret	 0
??0AMRFileDecoder@@QAE@XZ ENDP				; AMRFileDecoder::AMRFileDecoder
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GAMRFileDecoder@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GAMRFileDecoder@@UAEPAXI@Z PROC			; AMRFileDecoder::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1AMRFileDecoder@@UAE@XZ ; AMRFileDecoder::~AMRFileDecoder
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0a		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00018	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GAMRFileDecoder@@UAEPAXI@Z ENDP			; AMRFileDecoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ??1AMRFileDecoder@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AMRFileDecoder@@UAE@XZ PROC				; AMRFileDecoder::~AMRFileDecoder, COMDAT
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1AMRFileDecoder@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7AMRFileDecoder@@6B@
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 81   :     if(m_pBaseAddress)

  00037	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003a	85 c0		 test	 eax, eax
  0003c	74 0e		 je	 SHORT $LN1@AMRFileDec

; 82   :     {
; 83   :         UnmapViewOfFile(m_pBaseAddress);

  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 84   :         m_pBaseAddress = NULL;

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@AMRFileDec:

; 89   : 
; 90   : bool AMRFileDecoder::IsVaild()
; 91   : {
; 92   :     if(m_pBaseAddress == NULL || m_liFileSize == 0)
; 93   :         return false;
; 94   : 
; 95   :     // amr
; 96   :     char magic[8];
; 97   :     memcpy(magic, m_pBaseAddress, strlen(AMR_MAGIC_NUMBER));
; 98   : 
; 99   :     return strncmp(magic, AMR_MAGIC_NUMBER, strlen(AMR_MAGIC_NUMBER)) == 0;
; 100  : }
; 101  : 
; 102  : ULONGLONG AMRFileDecoder::GetTimeLength()
; 103  : {
; 104  :     if(!IsVaild())  return 0;
; 105  :    
; 106  :     return GetFrameCount() * amrFrameTime;
; 107  : }
; 108  : 
; 109  : WAVEFORMATEX AMRFileDecoder::GetWaveFromatX()
; 110  : {
; 111  :     WAVEFORMATEX wfmtx;
; 112  :     memset(&wfmtx, 0, sizeof(WAVEFORMATEX));
; 113  :     wfmtx.wFormatTag = WAVE_FORMAT_PCM;
; 114  :     wfmtx.nChannels = 1; // 
; 115  :     wfmtx.nSamplesPerSec = 8000; // 8khz
; 116  :     wfmtx.nAvgBytesPerSec = 16000;
; 117  :     wfmtx.nBlockAlign = 2;
; 118  :     wfmtx.wBitsPerSample = 16; // 16
; 119  :     wfmtx.cbSize = 0;
; 120  : 
; 121  :     return wfmtx;
; 122  : }
; 123  : 
; 124  : BOOL AMRFileDecoder::BeginDecode()
; 125  : {
; 126  :     if(!IsVaild())  return FALSE;
; 127  : 
; 128  :     Speech_Decode_FrameState *& speech_decoder_state = (Speech_Decode_FrameState*&)m_pvDecoderState;
; 129  : 
; 130  :     /* init decoder */
; 131  :     if(Speech_Decode_Frame_init(&speech_decoder_state, "Decode"))
; 132  :     {
; 133  :         if(speech_decoder_state)
; 134  :         {
; 135  :             Speech_Decode_Frame_exit(&speech_decoder_state);
; 136  :         }
; 137  : 
; 138  :         return FALSE;
; 139  :     }
; 140  : 
; 141  :     ATLASSERT(m_pvDecoderState);
; 142  : 
; 143  :     m_pCurAddress = m_pBaseAddress + strlen(AMR_MAGIC_NUMBER);
; 144  : 
; 145  :     return TRUE;
; 146  : }
; 147  : 
; 148  : void AMRFileDecoder::EndDecode()
; 149  : {
; 150  :     if(m_pvDecoderState)

  0004c	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00050	74 0f		 je	 SHORT $LN5@AMRFileDec

; 151  :     {
; 152  :         Speech_Decode_Frame_exit((Speech_Decode_FrameState**)&m_pvDecoderState);

  00052	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00055	e8 00 00 00 00	 call	 _Speech_Decode_Frame_exit

; 153  :         m_pvDecoderState = NULL;

  0005a	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN5@AMRFileDec:

; 88   : }

  00061	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00068	83 7e 38 08	 cmp	 DWORD PTR [esi+56], 8
  0006c	72 0c		 jb	 SHORT $LN30@AMRFileDec
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0006e	ff 76 24	 push	 DWORD PTR [esi+36]
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00077	83 c4 04	 add	 esp, 4
$LN30@AMRFileDec:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0007a	33 c0		 xor	 eax, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0007c	c7 46 38 07 00
	00 00		 mov	 DWORD PTR [esi+56], 7

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00083	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0008a	66 89 46 24	 mov	 WORD PTR [esi+36], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 88   : }

  0008e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00091	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00098	59		 pop	 ecx
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1AMRFileDecoder@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 24	 add	 ecx, 36			; 00000024H
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$??1AMRFileDecoder@@UAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1AMRFileDecoder@@UAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1AMRFileDecoder@@UAE@XZ ENDP				; AMRFileDecoder::~AMRFileDecoder
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?IsVaild@AMRFileDecoder@@UAE_NXZ
_TEXT	SEGMENT
_magic$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
?IsVaild@AMRFileDecoder@@UAE_NXZ PROC			; AMRFileDecoder::IsVaild, COMDAT
; _this$ = ecx

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 92   :     if(m_pBaseAddress == NULL || m_liFileSize == 0)

  00010	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00013	85 d2		 test	 edx, edx
  00015	74 3c		 je	 SHORT $LN1@IsVaild
  00017	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0001a	0b 41 14	 or	 eax, DWORD PTR [ecx+20]
  0001d	74 34		 je	 SHORT $LN1@IsVaild

; 93   :         return false;
; 94   : 
; 95   :     // amr
; 96   :     char magic[8];
; 97   :     memcpy(magic, m_pBaseAddress, strlen(AMR_MAGIC_NUMBER));

  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	89 45 f4	 mov	 DWORD PTR _magic$[ebp], eax
  00024	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]

; 98   : 
; 99   :     return strncmp(magic, AMR_MAGIC_NUMBER, strlen(AMR_MAGIC_NUMBER)) == 0;

  00028	6a 06		 push	 6
  0002a	66 89 45 f8	 mov	 WORD PTR _magic$[ebp+4], ax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR _magic$[ebp]
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	f7 d8		 neg	 eax
  00042	1b c0		 sbb	 eax, eax
  00044	40		 inc	 eax

; 100  : }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	33 cd		 xor	 ecx, ebp
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN1@IsVaild:
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	32 c0		 xor	 al, al
  00058	33 cd		 xor	 ecx, ebp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?IsVaild@AMRFileDecoder@@UAE_NXZ ENDP			; AMRFileDecoder::IsVaild
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?GetTimeLength@AMRFileDecoder@@UAE_KXZ
_TEXT	SEGMENT
?GetTimeLength@AMRFileDecoder@@UAE_KXZ PROC		; AMRFileDecoder::GetTimeLength, COMDAT
; _this$ = ecx

; 103  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 104  :     if(!IsVaild())  return 0;

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00008	ff d0		 call	 eax
  0000a	84 c0		 test	 al, al
  0000c	75 06		 jne	 SHORT $LN1@GetTimeLen
  0000e	33 c0		 xor	 eax, eax

; 105  :    
; 106  :     return GetFrameCount() * amrFrameTime;

  00010	33 d2		 xor	 edx, edx
  00012	5e		 pop	 esi

; 107  : }

  00013	c3		 ret	 0
$LN1@GetTimeLen:

; 105  :    
; 106  :     return GetFrameCount() * amrFrameTime;

  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?GetFrameCount@AMRFileDecoder@@AAEKXZ ; AMRFileDecoder::GetFrameCount
  0001b	33 d2		 xor	 edx, edx
  0001d	5e		 pop	 esi
  0001e	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00021	c1 e0 02	 shl	 eax, 2

; 107  : }

  00024	c3		 ret	 0
?GetTimeLength@AMRFileDecoder@@UAE_KXZ ENDP		; AMRFileDecoder::GetTimeLength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?GetWaveFromatX@AMRFileDecoder@@UAE?AUtWAVEFORMATEX@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetWaveFromatX@AMRFileDecoder@@UAE?AUtWAVEFORMATEX@@XZ PROC ; AMRFileDecoder::GetWaveFromatX, COMDAT
; _this$ = ecx

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  :     WAVEFORMATEX wfmtx;
; 112  :     memset(&wfmtx, 0, sizeof(WAVEFORMATEX));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 113  :     wfmtx.wFormatTag = WAVE_FORMAT_PCM;
; 114  :     wfmtx.nChannels = 1; // 
; 115  :     wfmtx.nSamplesPerSec = 8000; // 8khz
; 116  :     wfmtx.nAvgBytesPerSec = 16000;
; 117  :     wfmtx.nBlockAlign = 2;

  00009	b9 02 00 00 00	 mov	 ecx, 2
  0000e	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  00012	66 89 48 0c	 mov	 WORD PTR [eax+12], cx

; 118  :     wfmtx.wBitsPerSample = 16; // 16
; 119  :     wfmtx.cbSize = 0;

  00016	33 c9		 xor	 ecx, ecx
  00018	c7 40 0e 10 00
	00 00		 mov	 DWORD PTR [eax+14], 16	; 00000010H
  0001f	c7 00 01 00 01
	00		 mov	 DWORD PTR [eax], 65537	; 00010001H
  00025	c7 40 04 40 1f
	00 00		 mov	 DWORD PTR [eax+4], 8000	; 00001f40H
  0002c	c7 40 08 80 3e
	00 00		 mov	 DWORD PTR [eax+8], 16000 ; 00003e80H
  00033	66 89 48 10	 mov	 WORD PTR [eax+16], cx

; 120  : 
; 121  :     return wfmtx;
; 122  : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?GetWaveFromatX@AMRFileDecoder@@UAE?AUtWAVEFORMATEX@@XZ ENDP ; AMRFileDecoder::GetWaveFromatX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?BeginDecode@AMRFileDecoder@@UAEHXZ
_TEXT	SEGMENT
?BeginDecode@AMRFileDecoder@@UAEHXZ PROC		; AMRFileDecoder::BeginDecode, COMDAT
; _this$ = ecx

; 125  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 126  :     if(!IsVaild())  return FALSE;

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00008	ff d0		 call	 eax
  0000a	84 c0		 test	 al, al
  0000c	75 04		 jne	 SHORT $LN3@BeginDecod
  0000e	33 c0		 xor	 eax, eax
  00010	5e		 pop	 esi

; 146  : }

  00011	c3		 ret	 0
$LN3@BeginDecod:
  00012	57		 push	 edi

; 127  : 
; 128  :     Speech_Decode_FrameState *& speech_decoder_state = (Speech_Decode_FrameState*&)m_pvDecoderState;
; 129  : 
; 130  :     /* init decoder */
; 131  :     if(Speech_Decode_Frame_init(&speech_decoder_state, "Decode"))

  00013	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00016	e8 00 00 00 00	 call	 _Speech_Decode_Frame_init
  0001b	85 c0		 test	 eax, eax
  0001d	74 13		 je	 SHORT $LN2@BeginDecod

; 132  :     {
; 133  :         if(speech_decoder_state)

  0001f	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00023	74 08		 je	 SHORT $LN1@BeginDecod

; 134  :         {
; 135  :             Speech_Decode_Frame_exit(&speech_decoder_state);

  00025	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00028	e8 00 00 00 00	 call	 _Speech_Decode_Frame_exit
$LN1@BeginDecod:

; 136  :         }
; 137  : 
; 138  :         return FALSE;

  0002d	5f		 pop	 edi
  0002e	33 c0		 xor	 eax, eax
  00030	5e		 pop	 esi

; 146  : }

  00031	c3		 ret	 0
$LN2@BeginDecod:

; 139  :     }
; 140  : 
; 141  :     ATLASSERT(m_pvDecoderState);
; 142  : 
; 143  :     m_pCurAddress = m_pBaseAddress + strlen(AMR_MAGIC_NUMBER);

  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	83 c0 06	 add	 eax, 6
  00038	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 144  : 
; 145  :     return TRUE;

  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 146  : }

  00042	c3		 ret	 0
?BeginDecode@AMRFileDecoder@@UAEHXZ ENDP		; AMRFileDecoder::BeginDecode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?EndDecode@AMRFileDecoder@@UAEXXZ
_TEXT	SEGMENT
?EndDecode@AMRFileDecoder@@UAEXXZ PROC			; AMRFileDecoder::EndDecode, COMDAT
; _this$ = ecx

; 150  :     if(m_pvDecoderState)

  00000	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00004	56		 push	 esi
  00005	8d 71 20	 lea	 esi, DWORD PTR [ecx+32]
  00008	74 0d		 je	 SHORT $LN1@EndDecode

; 151  :     {
; 152  :         Speech_Decode_Frame_exit((Speech_Decode_FrameState**)&m_pvDecoderState);

  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 _Speech_Decode_Frame_exit

; 153  :         m_pvDecoderState = NULL;

  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@EndDecode:
  00017	5e		 pop	 esi

; 154  :     }
; 155  : }

  00018	c3		 ret	 0
?EndDecode@AMRFileDecoder@@UAEXXZ ENDP			; AMRFileDecoder::EndDecode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?IsEOF@AMRFileDecoder@@UAE_NXZ
_TEXT	SEGMENT
?IsEOF@AMRFileDecoder@@UAE_NXZ PROC			; AMRFileDecoder::IsEOF, COMDAT
; _this$ = ecx

; 159  :     return m_pCurAddress >= m_pBaseAddress + m_liFileSize;

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00006	39 41 1c	 cmp	 DWORD PTR [ecx+28], eax
  00009	1b c0		 sbb	 eax, eax
  0000b	40		 inc	 eax

; 160  : }

  0000c	c3		 ret	 0
?IsEOF@AMRFileDecoder@@UAE_NXZ ENDP			; AMRFileDecoder::IsEOF
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sp_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sp_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_homing.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_homing.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?Decode@AMRFileDecoder@@UAEKAAPAD@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -872					; size = 4
_pData$GSCopy$1$ = -868					; size = 4
_speech_decoder_state$1$ = -864				; size = 4
_mode$ = -860						; size = 4
_serial$ = -856						; size = 500
_pcmFrame$ = -356					; size = 320
_packed_bits$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_pData$ = 8						; size = 4
?Decode@AMRFileDecoder@@UAEKAAPAD@Z PROC		; AMRFileDecoder::Decode, COMDAT
; _this$ = ecx

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 03 00
	00		 sub	 esp, 872		; 00000368H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  00016	89 85 9c fc ff
	ff		 mov	 DWORD PTR _pData$GSCopy$1$[ebp], eax

; 164  :     // 0
; 165  :     if(m_pCurAddress >= m_pBaseAddress + m_liFileSize)

  0001c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0001f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00022	57		 push	 edi
  00023	8b 79 1c	 mov	 edi, DWORD PTR [ecx+28]
  00026	89 8d 98 fc ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002c	3b f8		 cmp	 edi, eax
  0002e	72 13		 jb	 SHORT $LN12@Decode

; 166  :         return 0;

  00030	33 c0		 xor	 eax, eax
  00032	5f		 pop	 edi

; 241  :     }
; 242  : 
; 243  :     // bytes
; 244  :     return L_FRAME * sizeof(Word16);
; 245  : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
$LN12@Decode:

; 167  : 
; 168  :     Word16 serial[SERIAL_FRAMESIZE];   /* coded bits                    */
; 169  :     Word16 pcmFrame[L_FRAME];          /* Synthesis                     */
; 170  : 
; 171  :     UWord8 toc, q, ft;
; 172  :     UWord8 packed_bits[MAX_PACKED_SIZE];
; 173  : 
; 174  :     RXFrameType rx_type = (RXFrameType)0;
; 175  :     Mode mode = (Mode)0;
; 176  : 
; 177  :     Word16 reset_flag = 0;
; 178  :     Word16 reset_flag_old = 1;
; 179  : 
; 180  :     Speech_Decode_FrameState *speech_decoder_state = (Speech_Decode_FrameState*)m_pvDecoderState;

  00043	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00046	53		 push	 ebx

; 181  : 
; 182  :     // 
; 183  :     {
; 184  :         // tocAmr
; 185  :         toc = *m_pCurAddress++;

  00047	8a 3f		 mov	 bh, BYTE PTR [edi]
  00049	47		 inc	 edi

; 188  :         ft = (toc >> 3) & 0x0F;

  0004a	8a df		 mov	 bl, bh
  0004c	89 85 a0 fc ff
	ff		 mov	 DWORD PTR _speech_decoder_state$1$[ebp], eax
  00052	c0 eb 03	 shr	 bl, 3
  00055	80 e3 0f	 and	 bl, 15			; 0000000fH
  00058	c7 85 a4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _mode$[ebp], 0

; 189  :         memcpy(packed_bits, m_pCurAddress, amrPackedSize[ft]);

  00062	0f b6 c3	 movzx	 eax, bl
  00065	56		 push	 esi
  00066	89 79 1c	 mov	 DWORD PTR [ecx+28], edi
  00069	8b 34 85 00 00
	00 00		 mov	 esi, DWORD PTR _amrPackedSize[eax*4]
  00070	8d 45 dc	 lea	 eax, DWORD PTR _packed_bits$[ebp]
  00073	56		 push	 esi
  00074	57		 push	 edi
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _memcpy

; 190  :         m_pCurAddress += amrPackedSize[ft];

  0007b	8b 8d 98 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00081	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 191  : 
; 192  :         rx_type = UnpackBits(q, ft, packed_bits, &mode, &serial[1]);

  00084	0f b6 d3	 movzx	 edx, bl
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sp_dec.c

; 245  : 	if (ft == 15 || (ft > 8 && ft < 15))

  0008d	66 83 fa 0f	 cmp	 dx, 15			; 0000000fH
  00091	74 3a		 je	 SHORT $LN32@Decode
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 187  :         q  = (toc >> 2) & 0x01;

  00093	8d 85 aa fc ff
	ff		 lea	 eax, DWORD PTR _serial$[ebp+2]
  00099	c0 ef 02	 shr	 bh, 2
  0009c	50		 push	 eax
  0009d	8d 85 a4 fc ff
	ff		 lea	 eax, DWORD PTR _mode$[ebp]
  000a3	80 e7 01	 and	 bh, 1
  000a6	50		 push	 eax
  000a7	8d 45 dc	 lea	 eax, DWORD PTR _packed_bits$[ebp]
  000aa	8a cf		 mov	 cl, bh
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _UnpackBits
  000b2	8b f8		 mov	 edi, eax
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 193  : 
; 194  :         if (rx_type == RX_NO_DATA) 

  000b7	83 ff 07	 cmp	 edi, 7
  000ba	74 16		 je	 SHORT $LN46@Decode

; 197  :         }
; 198  :         else 
; 199  :         {
; 200  :             speech_decoder_state->prev_mode = mode;

  000bc	8b 9d a0 fc ff
	ff		 mov	 ebx, DWORD PTR _speech_decoder_state$1$[ebp]
  000c2	8b b5 a4 fc ff
	ff		 mov	 esi, DWORD PTR _mode$[ebp]
  000c8	89 73 0c	 mov	 DWORD PTR [ebx+12], esi
  000cb	eb 0e		 jmp	 SHORT $LN47@Decode
$LN32@Decode:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sp_dec.c

; 248  : 		return RX_NO_DATA;

  000cd	bf 07 00 00 00	 mov	 edi, 7
$LN46@Decode:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 196  :             mode = speech_decoder_state->prev_mode;

  000d2	8b 9d a0 fc ff
	ff		 mov	 ebx, DWORD PTR _speech_decoder_state$1$[ebp]
  000d8	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
$LN47@Decode:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_homing.c

; 152  :     return dhf_test(input_frame, mode, prmnofsf[mode]);

  000db	0f b7 04 75 00
	00 00 00	 movzx	 eax, WORD PTR _prmnofsf[esi*2]
  000e3	8d 8d aa fc ff
	ff		 lea	 ecx, DWORD PTR _serial$[ebp+2]
  000e9	50		 push	 eax
  000ea	8b d6		 mov	 edx, esi
  000ec	e8 00 00 00 00	 call	 _dhf_test
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 207  :             reset_flag = decoder_homing_frame_test_first(&serial[1], mode);

  000f1	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_homing.c

; 152  :     return dhf_test(input_frame, mode, prmnofsf[mode]);

  000f4	83 c4 04	 add	 esp, 4
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 210  :         if ((reset_flag != 0) && (reset_flag_old != 0))

  000f7	66 85 c0	 test	 ax, ax
  000fa	74 1b		 je	 SHORT $LN8@Decode

; 211  :         {
; 212  :             for (int i = 0; i < L_FRAME; i++)
; 213  :             {
; 214  :                 pcmFrame[i] = EHF_MASK;

  000fc	b8 08 00 08 00	 mov	 eax, 524296		; 00080008H
  00101	8d bd 9c fe ff
	ff		 lea	 edi, DWORD PTR _pcmFrame$[ebp]
  00107	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0010c	f3 ab		 rep stosd

; 221  :         }
; 222  : 
; 223  :         /* if not homed: check whether current frame is a homing frame */
; 224  :         if (reset_flag_old == 0)
; 225  :         {
; 226  :             /* check whole frame */
; 227  :             reset_flag = decoder_homing_frame_test(&serial[1], mode);
; 228  :         }
; 229  :         /* reset decoder if current frame is a homing frame */
; 230  :         if (reset_flag != 0)
; 231  :         {
; 232  :             Speech_Decode_Frame_reset(speech_decoder_state);

  0010e	8b cb		 mov	 ecx, ebx
  00110	e8 00 00 00 00	 call	 _Speech_Decode_Frame_reset
  00115	eb 1b		 jmp	 SHORT $LN2@Decode
$LN8@Decode:

; 215  :             }
; 216  :         }
; 217  :         else
; 218  :         {     
; 219  :             /* decode frame */
; 220  :             Speech_Decode_Frame(speech_decoder_state, mode, &serial[1], rx_type, pcmFrame);

  00117	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _pcmFrame$[ebp]
  0011d	8b d6		 mov	 edx, esi
  0011f	50		 push	 eax
  00120	8d 85 aa fc ff
	ff		 lea	 eax, DWORD PTR _serial$[ebp+2]
  00126	8b cb		 mov	 ecx, ebx
  00128	57		 push	 edi
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _Speech_Decode_Frame
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Decode:

; 233  :         }
; 234  :         reset_flag_old = reset_flag;
; 235  :     }
; 236  :     
; 237  :     // 
; 238  :     if(pData)

  00132	8b bd 9c fc ff
	ff		 mov	 edi, DWORD PTR _pData$GSCopy$1$[ebp]
  00138	8b 3f		 mov	 edi, DWORD PTR [edi]
  0013a	85 ff		 test	 edi, edi
  0013c	74 0d		 je	 SHORT $LN1@Decode

; 239  :     {
; 240  :         memcpy(pData, pcmFrame, sizeof(Word16) * L_FRAME);

  0013e	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00143	8d b5 9c fe ff
	ff		 lea	 esi, DWORD PTR _pcmFrame$[ebp]
  00149	f3 a5		 rep movsd
$LN1@Decode:

; 241  :     }
; 242  : 
; 243  :     // bytes
; 244  :     return L_FRAME * sizeof(Word16);
; 245  : }

  0014b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014e	b8 40 01 00 00	 mov	 eax, 320		; 00000140H
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	33 cd		 xor	 ecx, ebp
  00157	5f		 pop	 edi
  00158	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c2 04 00	 ret	 4
?Decode@AMRFileDecoder@@UAEKAAPAD@Z ENDP		; AMRFileDecoder::Decode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?GetDecodedFrameMaxSize@AMRFileDecoder@@UAEKXZ
_TEXT	SEGMENT
?GetDecodedFrameMaxSize@AMRFileDecoder@@UAEKXZ PROC	; AMRFileDecoder::GetDecodedFrameMaxSize, COMDAT
; _this$ = ecx

; 249  :     return L_FRAME * sizeof(Word16);

  00000	b8 40 01 00 00	 mov	 eax, 320		; 00000140H

; 250  : }

  00005	c3		 ret	 0
?GetDecodedFrameMaxSize@AMRFileDecoder@@UAEKXZ ENDP	; AMRFileDecoder::GetDecodedFrameMaxSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?GetDecodedMaxSize@AMRFileDecoder@@UAEKXZ
_TEXT	SEGMENT
?GetDecodedMaxSize@AMRFileDecoder@@UAEKXZ PROC		; AMRFileDecoder::GetDecodedMaxSize, COMDAT
; _this$ = ecx

; 253  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 254  :     return GetFrameCount() * GetDecodedFrameMaxSize();

  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	ff 50 28	 call	 DWORD PTR [eax+40]
  00009	8b cf		 mov	 ecx, edi
  0000b	8b f0		 mov	 esi, eax
  0000d	e8 00 00 00 00	 call	 ?GetFrameCount@AMRFileDecoder@@AAEKXZ ; AMRFileDecoder::GetFrameCount
  00012	5f		 pop	 edi
  00013	0f af c6	 imul	 eax, esi
  00016	5e		 pop	 esi

; 255  : }

  00017	c3		 ret	 0
?GetDecodedMaxSize@AMRFileDecoder@@UAEKXZ ENDP		; AMRFileDecoder::GetDecodedMaxSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?SetFilePathName@AMRFileDecoder@@UAEXPB_W@Z
_TEXT	SEGMENT
_liFileSize$ = -8					; size = 8
_lpszFile$ = 8						; size = 4
?SetFilePathName@AMRFileDecoder@@UAEXPB_W@Z PROC	; AMRFileDecoder::SetFilePathName, COMDAT
; _this$ = ecx

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 306  : 			: _CSTD wcslen(_First));

  00009	8b 7d 08	 mov	 edi, DWORD PTR _lpszFile$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 258  : {

  0000c	8b f1		 mov	 esi, ecx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 306  : 			: _CSTD wcslen(_First));

  0000e	66 83 3f 00	 cmp	 WORD PTR [edi], 0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 259  :     if(m_sFilePathName == lpszFile)

  00012	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 306  : 			: _CSTD wcslen(_First));

  00015	75 04		 jne	 SHORT $LN14@SetFilePat
  00017	33 d2		 xor	 edx, edx
  00019	eb 14		 jmp	 SHORT $LN15@SetFilePat
$LN14@SetFilePat:
  0001b	8b d7		 mov	 edx, edi
  0001d	8d 5a 02	 lea	 ebx, DWORD PTR [edx+2]
$LL16@SetFilePat:
  00020	66 8b 02	 mov	 ax, WORD PTR [edx]
  00023	83 c2 02	 add	 edx, 2
  00026	66 85 c0	 test	 ax, ax
  00029	75 f5		 jne	 SHORT $LL16@SetFilePat
  0002b	2b d3		 sub	 edx, ebx
  0002d	d1 fa		 sar	 edx, 1
$LN15@SetFilePat:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  0002f	52		 push	 edx
  00030	57		 push	 edi
  00031	ff 71 10	 push	 DWORD PTR [ecx+16]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);

  0003a	85 c0		 test	 eax, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 259  :     if(m_sFilePathName == lpszFile)

  0003c	0f 84 cc 00 00
	00		 je	 $LN6@SetFilePat

; 260  :         return;
; 261  : 
; 262  :     // 
; 263  :     if(m_pBaseAddress)

  00042	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00045	85 c0		 test	 eax, eax
  00047	74 0e		 je	 SHORT $LN4@SetFilePat

; 264  :     {
; 265  :         UnmapViewOfFile(m_pBaseAddress);

  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 266  :         m_pBaseAddress = NULL;

  00050	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@SetFilePat:

; 267  :     }
; 268  : 
; 269  :     // 
; 270  :     EndDecode();

  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	8b ce		 mov	 ecx, esi
  0005b	ff 50 1c	 call	 DWORD PTR [eax+28]

; 271  : 
; 272  :     // 
; 273  :     m_pCurAddress = NULL;
; 274  :     m_liFileSize = 0;
; 275  :     m_dwFrameCount = 0;
; 276  :     m_pvDecoderState = NULL;
; 277  : 
; 278  :     // 
; 279  :     HANDLE hFileAmr = CreateFile(lpszFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  0005e	6a 00		 push	 0
  00060	68 80 00 00 00	 push	 128			; 00000080H
  00065	6a 03		 push	 3
  00067	6a 00		 push	 0
  00069	6a 01		 push	 1
  0006b	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00070	57		 push	 edi
  00071	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00078	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0007f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00086	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0008d	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileW@28
  0009a	8b f8		 mov	 edi, eax

; 280  :     ATLASSERT(hFileAmr);
; 281  :     if(hFileAmr == NULL)    return ;

  0009c	85 ff		 test	 edi, edi
  0009e	74 6e		 je	 SHORT $LN6@SetFilePat

; 282  : 
; 283  :     // 
; 284  :     LARGE_INTEGER liFileSize;
; 285  :     memset(&liFileSize, 0, sizeof(LARGE_INTEGER));
; 286  :     if(!GetFileSizeEx(hFileAmr, &liFileSize))

  000a0	8d 45 f8	 lea	 eax, DWORD PTR _liFileSize$[ebp]
  000a3	0f 57 c0	 xorps	 xmm0, xmm0
  000a6	50		 push	 eax
  000a7	57		 push	 edi
  000a8	66 0f d6 45 f8	 movq	 QWORD PTR _liFileSize$[ebp], xmm0
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSizeEx@8
  000b3	85 c0		 test	 eax, eax
  000b5	75 10		 jne	 SHORT $LN2@SetFilePat

; 287  :     {
; 288  :         CloseHandle(hFileAmr);

  000b7	57		 push	 edi
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx

; 306  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
$LN2@SetFilePat:

; 289  :         return;
; 290  :     }
; 291  :     m_liFileSize = liFileSize.QuadPart;

  000c7	8b 45 f8	 mov	 eax, DWORD PTR _liFileSize$[ebp]

; 292  : 
; 293  :     // 
; 294  :     HANDLE hFileMapping = CreateFileMapping(hFileAmr, NULL, PAGE_READONLY, 0, 0, NULL);

  000ca	6a 00		 push	 0
  000cc	6a 00		 push	 0
  000ce	6a 00		 push	 0
  000d0	6a 02		 push	 2
  000d2	6a 00		 push	 0
  000d4	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000d7	8b 45 fc	 mov	 eax, DWORD PTR _liFileSize$[ebp+4]
  000da	57		 push	 edi
  000db	89 46 14	 mov	 DWORD PTR [esi+20], eax
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileMappingW@24

; 295  :     CloseHandle(hFileAmr);

  000e4	57		 push	 edi
  000e5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseHandle@4
  000eb	8b d8		 mov	 ebx, eax
  000ed	ff d7		 call	 edi

; 296  :     ATLASSERT(hFileMapping);
; 297  :     if(hFileMapping == NULL) return ;

  000ef	85 db		 test	 ebx, ebx
  000f1	74 1b		 je	 SHORT $LN6@SetFilePat

; 298  : 
; 299  :     // 
; 300  :     m_pBaseAddress = (LPSTR)MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);

  000f3	6a 00		 push	 0
  000f5	6a 00		 push	 0
  000f7	6a 00		 push	 0
  000f9	6a 04		 push	 4
  000fb	53		 push	 ebx
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapViewOfFile@20

; 301  :     CloseHandle(hFileMapping);

  00102	53		 push	 ebx
  00103	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00106	ff d7		 call	 edi

; 302  :     ATLASSERT(m_pBaseAddress);
; 303  : 
; 304  :     // 
; 305  :     m_pCurAddress = m_pBaseAddress;

  00108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010b	89 46 1c	 mov	 DWORD PTR [esi+28], eax
$LN6@SetFilePat:
  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5b		 pop	 ebx

; 306  : }

  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c2 04 00	 ret	 4
?SetFilePathName@AMRFileDecoder@@UAEXPB_W@Z ENDP	; AMRFileDecoder::SetFilePathName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
;	COMDAT ?GetFrameCount@AMRFileDecoder@@AAEKXZ
_TEXT	SEGMENT
?GetFrameCount@AMRFileDecoder@@AAEKXZ PROC		; AMRFileDecoder::GetFrameCount, COMDAT
; _this$ = ecx

; 310  :     ATLASSERT(IsVaild());
; 311  : 
; 312  :     if(m_dwFrameCount <= 0)

  00000	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00004	77 40		 ja	 SHORT $LN11@GetFrameCo

; 313  :     {
; 314  :         m_dwFrameCount = 0;
; 315  : 
; 316  :         LPSTR pCur = m_pBaseAddress + strlen(AMR_MAGIC_NUMBER);

  00006	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 317  : 
; 318  :         unsigned char toc = 0, ft = 0;
; 319  :         while (pCur < m_pBaseAddress + m_liFileSize)

  0000b	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  0000e	8d 72 06	 lea	 esi, DWORD PTR [edx+6]
  00011	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00018	03 fa		 add	 edi, edx
  0001a	3b f7		 cmp	 esi, edi
  0001c	73 22		 jae	 SHORT $LN10@GetFrameCo
  0001e	33 d2		 xor	 edx, edx
$LL2@GetFrameCo:

; 320  :         {
; 321  :             // tocAmr
; 322  :             toc = *pCur++;
; 323  :             ft = (toc >> 3) & 0x0F;
; 324  :             pCur += amrPackedSize[ft];

  00020	0f b6 06	 movzx	 eax, BYTE PTR [esi]

; 325  :             ++m_dwFrameCount;

  00023	42		 inc	 edx
  00024	c1 e8 03	 shr	 eax, 3
  00027	46		 inc	 esi
  00028	83 e0 0f	 and	 eax, 15			; 0000000fH
  0002b	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  0002e	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _amrPackedSize[eax*4]
  00035	03 f0		 add	 esi, eax
  00037	3b f7		 cmp	 esi, edi
  00039	72 e5		 jb	 SHORT $LL2@GetFrameCo

; 326  :         }
; 327  :     }
; 328  : 
; 329  :     return m_dwFrameCount;

  0003b	5f		 pop	 edi
  0003c	8b c2		 mov	 eax, edx
  0003e	5e		 pop	 esi

; 330  : }

  0003f	c3		 ret	 0
$LN10@GetFrameCo:

; 326  :         }
; 327  :     }
; 328  : 
; 329  :     return m_dwFrameCount;

  00040	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi

; 330  : }

  00045	c3		 ret	 0
$LN11@GetFrameCo:

; 326  :         }
; 327  :     }
; 328  : 
; 329  :     return m_dwFrameCount;

  00046	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]

; 330  : }

  00049	c3		 ret	 0
?GetFrameCount@AMRFileDecoder@@AAEKXZ ENDP		; AMRFileDecoder::GetFrameCount
_TEXT	ENDS
END
