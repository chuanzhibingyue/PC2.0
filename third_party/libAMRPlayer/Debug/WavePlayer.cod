; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\WavePlayer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA	; ATL::CComApartment::ATL_CREATE_OBJECT
PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	??_C@_13HADIAKP@?$AAS?$AA?$AA@			; `string'
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	??_C@_13LHMFKAAD@?$AAM?$AA?$AA@			; `string'
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@			; `string'
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	??_C@_13OPKGLAFF@?$AAB?$AA?$AA@			; `string'
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@	; `string'
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	?m_nLevel@CTrace@ATL@@1IA			; ATL::CTrace::m_nLevel
PUBLIC	?m_nCategory@CTrace@ATL@@1IA			; ATL::CTrace::m_nCategory
PUBLIC	?m_nLastCategory@CTrace@ATL@@1IA		; ATL::CTrace::m_nLastCategory
PUBLIC	?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A	; ATL::CTrace::m_nMap
PUBLIC	_IID_IInternalConnection
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	?cbNeverDelete@CRegParser@ATL@@1HB		; ATL::CRegParser::cbNeverDelete
PUBLIC	_CLSID_Registrar
PUBLIC	?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ ; ATL::CVarTypeInfo<char>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ ; ATL::CVarTypeInfo<unsigned char>::pmField
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	_IID_IRegistrar
PUBLIC	?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ ; ATL::CVarTypeInfo<char *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ ; ATL::CVarTypeInfo<unsigned char *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ ; ATL::CVarTypeInfo<short>::pmField
PUBLIC	?s_pfnPrevHook@CNoUIAssertHook@ATL@@0P6AHHPADPAH@ZA ; ATL::CNoUIAssertHook::s_pfnPrevHook
PUBLIC	?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ ; ATL::CVarTypeInfo<short *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ ; ATL::CVarTypeInfo<unsigned short>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ ; ATL::CVarTypeInfo<unsigned short *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ ; ATL::CVarTypeInfo<int>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ ; ATL::CVarTypeInfo<int *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ ; ATL::CVarTypeInfo<unsigned int>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ ; ATL::CVarTypeInfo<unsigned int *>::pmField
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ ; ATL::CVarTypeInfo<long>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ ; ATL::CVarTypeInfo<long *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ ; ATL::CVarTypeInfo<unsigned long>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ ; ATL::CVarTypeInfo<unsigned long *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ ; ATL::CVarTypeInfo<__int64>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ ; ATL::CVarTypeInfo<__int64 *>::pmField
PUBLIC	_LIBID_ATLLib
PUBLIC	?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ ; ATL::CVarTypeInfo<float>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ ; ATL::CVarTypeInfo<float *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ ; ATL::CVarTypeInfo<double>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ ; ATL::CVarTypeInfo<double *>::pmField
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ ; ATL::CVarTypeInfo<wchar_t *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ ; ATL::CVarTypeInfo<wchar_t * *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown *>::pmField
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown * *>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch *>::pmField
PUBLIC	??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@ ; `string'
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@	; `string'
PUBLIC	??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch * *>::pmField
PUBLIC	??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@ ; `string'
PUBLIC	?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY>::pmField
PUBLIC	?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY *>::pmField
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	_IID_IAxWinAmbientDispatch
;	COMDAT ?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA
_BSS	SEGMENT
?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA DD 01H DUP (?) ; ATL::CComApartment::ATL_CREATE_OBJECT
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?m_nLevel@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLevel@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLevel
_BSS	ENDS
;	COMDAT ?m_nLastCategory@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLastCategory@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLastCategory
_BSS	ENDS
;	COMDAT ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A
_BSS	SEGMENT
?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A DB 02080H DUP (?) ; ATL::CTrace::m_nMap
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
;	COMDAT ?s_pfnPrevHook@CNoUIAssertHook@ATL@@0P6AHHPADPAH@ZA
_BSS	SEGMENT
?s_pfnPrevHook@CNoUIAssertHook@ATL@@0P6AHHPADPAH@ZA DD 01H DUP (?) ; ATL::CNoUIAssertHook::s_pfnPrevHook
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY>::pmField
CONST	ENDS
;	COMDAT ??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@ DB 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch * *>::pmField
CONST	ENDS
;	COMDAT ??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ DB 'S'
	DB	00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@ DB 'S', 00H, 'Y'
	DB	00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@ DB 'S'
	DB	00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H, 'T', 00H
	DB	'Y', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@ DB 'S', 00H, 'A', 00H, 'M', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@ DB 'M', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ DB 'H'
	DB	00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@ DB 'I'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@ DB 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown * *>::pmField
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t * *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ DD 08H ; ATL::CVarTypeInfo<double *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ DD 08H ; ATL::CVarTypeInfo<double>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ DD 08H ; ATL::CVarTypeInfo<float *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ DD 08H ; ATL::CVarTypeInfo<float>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64>::pmField
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64 *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ DD 08H ; ATL::CVarTypeInfo<long *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ DD 08H ; ATL::CVarTypeInfo<long>::pmField
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ DD 08H ; ATL::CVarTypeInfo<int *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ DD 08H ; ATL::CVarTypeInfo<int>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ DD 08H ; ATL::CVarTypeInfo<short *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ DD 08H ; ATL::CVarTypeInfo<short>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char *>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ DD 08H ; ATL::CVarTypeInfo<char *>::pmField
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char>::pmField
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ DD 08H ; ATL::CVarTypeInfo<char>::pmField
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?cbNeverDelete@CRegParser@ATL@@1HB
CONST	SEGMENT
?cbNeverDelete@CRegParser@ATL@@1HB DD 0cH		; ATL::CRegParser::cbNeverDelete
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB DD FLAT:??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ ; ATL::CRegParser::rgszNeverDelete
	DD	FLAT:??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@
	DD	FLAT:??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@
	DD	FLAT:??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
	DD	FLAT:??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@
	DD	FLAT:??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@
	DD	FLAT:??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@
	DD	FLAT:??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@
	DD	FLAT:??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT ?m_nCategory@CTrace@ATL@@1IA
_DATA	SEGMENT
?m_nCategory@CTrace@ATL@@1IA DD 0ffffffffH		; ATL::CTrace::m_nCategory
_DATA	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT ??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ DB 'D', 00H, 'e', 00H
	DB	'l', 00H, 'e', 00H, 't', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ ; ATL::szDelete
CONST	ENDS
;	COMDAT ??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ DB 'N'
	DB	00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; ATL::szNoRemove
CONST	ENDS
;	COMDAT ??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; ATL::szForceRemove
CONST	ENDS
;	COMDAT ??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@ DB 'V', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@ ; ATL::szValToken
CONST	ENDS
;	COMDAT ??_C@_13OPKGLAFF@?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_13OPKGLAFF@?$AAB?$AA?$AA@ DB 'B', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:??_C@_13OPKGLAFF@?$AAB?$AA?$AA@ ; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@ DB 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@ ; ATL::szDwordVal
CONST	ENDS
;	COMDAT ??_C@_13LHMFKAAD@?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_13LHMFKAAD@?$AAM?$AA?$AA@ DB 'M', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:??_C@_13LHMFKAAD@?$AAM?$AA?$AA@ ; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ??_C@_13HADIAKP@?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_13HADIAKP@?$AAS?$AA?$AA@ DB 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:??_C@_13HADIAKP@?$AAS?$AA?$AA@ ; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT ??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ DB 'A', 00H, 'p', 00H
	DB	'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@ DB 'C', 00H, 'L', 00H
	DB	'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	??$AtlMultiply@I@ATL@@YAJPAIII@Z		; ATL::AtlMultiply<unsigned int>
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ	; ATL::CTraceCategoryEx<2,0>::operator unsigned int
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ	; ATL::CTraceCategoryEx<32,0>::operator unsigned int
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	?GetCategoryName@CTrace@ATL@@CAPA_WI@Z		; ATL::CTrace::GetCategoryName
PUBLIC	?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z		; ATL::CTrace::TraceV
PUBLIC	?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z		; ATL::CTrace::TraceV
PUBLIC	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z	; ATL::CTrace::RegisterCategory
PUBLIC	??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
PUBLIC	??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
PUBLIC	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
PUBLIC	?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
PUBLIC	?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
PUBLIC	??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ	; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	_hypot
PUBLIC	_ceilf
PUBLIC	?ceil@@YAMM@Z					; ceil
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0WavePlayer@@QAE@XZ				; WavePlayer::WavePlayer
PUBLIC	??1WavePlayer@@QAE@XZ				; WavePlayer::~WavePlayer
PUBLIC	?Play@WavePlayer@@QAEXPB_WPAK@Z			; WavePlayer::Play
PUBLIC	?Pause@WavePlayer@@QAEXXZ			; WavePlayer::Pause
PUBLIC	?Resume@WavePlayer@@QAEXXZ			; WavePlayer::Resume
PUBLIC	?Stop@WavePlayer@@QAEXXZ			; WavePlayer::Stop
PUBLIC	?GetAudioLength@WavePlayer@@QAEKPB_W@Z		; WavePlayer::GetAudioLength
PUBLIC	?SetVolume@WavePlayer@@QAEXK@Z			; WavePlayer::SetVolume
PUBLIC	?SetCallback@WavePlayer@@QAEXPAVISoundCallBack@@J@Z ; WavePlayer::SetCallback
PUBLIC	?WaveOutProc@WavePlayer@@KGHPAUHWAVEOUT__@@IKKK@Z ; WavePlayer::WaveOutProc
PUBLIC	?WaveOutProcImpl@WavePlayer@@IAEHPAUHWAVEOUT__@@IKK@Z ; WavePlayer::WaveOutProcImpl
PUBLIC	?PlayThread@WavePlayer@@KGIPAX@Z		; WavePlayer::PlayThread
PUBLIC	?PlayThreadProcImpl@WavePlayer@@IAEIXZ		; WavePlayer::PlayThreadProcImpl
PUBLIC	?DecodeThread@WavePlayer@@KGIPAX@Z		; WavePlayer::DecodeThread
PUBLIC	?DecodeThreadProcImpl@WavePlayer@@IAEIXZ	; WavePlayer::DecodeThreadProcImpl
PUBLIC	?allocBlocks@WavePlayer@@IAEPAUwavehdr_tag@@HH@Z ; WavePlayer::allocBlocks
PUBLIC	?freeBlocks@WavePlayer@@IAEXPAUwavehdr_tag@@@Z	; WavePlayer::freeBlocks
PUBLIC	?UnInit@WavePlayer@@IAEXXZ			; WavePlayer::UnInit
PUBLIC	?OnPlayFinished@WavePlayer@@IAEXXZ		; WavePlayer::OnPlayFinished
PUBLIC	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z		; std::_Debug_pointer<char>
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_1KC@PGLOMAAO@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@ ; `string'
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@ ; `string'
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@ ; `string'
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@ ; `string'
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@ ; `string'
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@ ; `string'
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@ ; `string'
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@ ; `string'
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@ ; `string'
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@		; `string'
PUBLIC	??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_1KC@IFBFKCIN@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1KA@IOKHNBGA@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_0FA@LHJMKFAC@d?3?2program?5files?5?$CIx86?$CJ?2microsoft@ ; `string'
PUBLIC	??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA ; `ATL::AtlWinModuleInit'::`2'::__LINE__Var
PUBLIC	??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?__LINE__Var@?1???0WavePlayer@@QAE@XZ@4JA	; `WavePlayer::WavePlayer'::`2'::__LINE__Var
PUBLIC	??_C@_1BO@HAKCMIIN@?$AAm?$AA_?$AAh?$AAE?$AAv?$AAe?$AAn?$AAt?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1JE@KOPMJDFJ@?$AAe?$AA?3?$AA?2?$AAm?$AAy?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAc?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?2?$AAp?$AAc?$AA2?$AA?4?$AA0?$AAt?$AAr?$AAu?$AAn?$AAk?$AA?2?$AAp?$AAc?$AA2?$AA?4@ ; `string'
PUBLIC	??_C@_1BG@MHLLCDAC@?$AAm?$AA_?$AAp?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??Play@WavePlayer@@QAEXPB_WPAK@Z@4JA ; `WavePlayer::Play'::`2'::__LINE__Var
PUBLIC	??_C@_1CA@FHBIINOD@?$AAm?$AA_?$AAh?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@BEMNJFMJ@?$AAm?$AA_?$AAh?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAP?$AAl?$AAa?$AAy?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??DecodeThreadProcImpl@WavePlayer@@IAEIXZ@4JA ; `WavePlayer::DecodeThreadProcImpl'::`2'::__LINE__Var
PUBLIC	??_C@_1BI@LPCBEODC@?$AAp?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAB?$AAa?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KI@FCBEFGEA@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1IO@OGGFNDFH@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@447a0000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__wcscpy_s:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__ResumeThread@4:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__CreateEventW@16:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__waveOutSetVolume@8:PROC
EXTRN	__imp__waveOutOpen@24:PROC
EXTRN	__imp__waveOutClose@4:PROC
EXTRN	__imp__waveOutPrepareHeader@12:PROC
EXTRN	__imp__waveOutUnprepareHeader@12:PROC
EXTRN	__imp__waveOutWrite@12:PROC
EXTRN	__imp__waveOutPause@4:PROC
EXTRN	__imp__waveOutRestart@4:PROC
EXTRN	__imp__waveOutReset@4:PROC
EXTRN	__imp__swprintf_s:PROC
EXTRN	__imp___vsnwprintf_s:PROC
EXTRN	__imp___vscwprintf:PROC
EXTRN	__imp__ceil:PROC
EXTRN	__imp___hypot:PROC
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
EXTRN	__imp_??0_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_??1_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_??0id@locale@std@@QAE@I@Z:PROC
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	__imp_?_Syserror_map@std@@YAPBDH@Z:PROC
EXTRN	__imp_?_Winerror_map@std@@YAPBDH@Z:PROC
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	??0AMRFileDecoder@@QAE@XZ:PROC			; AMRFileDecoder::AMRFileDecoder
EXTRN	??0AMRFileDecoder@@QAE@PB_W@Z:PROC		; AMRFileDecoder::AMRFileDecoder
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__ultod3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	___ImageBase:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_BSS	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 028H DUP (?)	; ATL::_AtlComModule
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceGeneral$initializer$ DD FLAT:??__EatlTraceGeneral@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'm'
	DB	00H, '_', 00H, 'p', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IO@OGGFNDFH@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@OGGFNDFH@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'd'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KI@FCBEFGEA@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KI@FCBEFGEA@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'd'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'c', 00H, 'o'
	DB	00H, 'l', 00H, 'l', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ DB 'n'
	DB	00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'n', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H, '_', 00H, 'n'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@LPCBEODC@?$AAp?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAB?$AAa?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@LPCBEODC@?$AAp?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAB?$AAa?$AAs?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H
	DB	'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DecodeThreadProcImpl@WavePlayer@@IAEIXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DecodeThreadProcImpl@WavePlayer@@IAEIXZ@4JA DD 01d8H ; `WavePlayer::DecodeThreadProcImpl'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BM@BEMNJFMJ@?$AAm?$AA_?$AAh?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAP?$AAl?$AAa?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@BEMNJFMJ@?$AAm?$AA_?$AAh?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAP?$AAl?$AAa?$AAy?$AA?$AA@ DB 'm'
	DB	00H, '_', 00H, 'h', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'd', 00H, 'P', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@FHBIINOD@?$AAm?$AA_?$AAh?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@FHBIINOD@?$AAm?$AA_?$AAh?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$AA@ DB 'm'
	DB	00H, '_', 00H, 'h', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'd', 00H, 'D', 00H, 'e', 00H, 'c', 00H, 'o', 00H, 'd'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Play@WavePlayer@@QAEXPB_WPAK@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Play@WavePlayer@@QAEXPB_WPAK@Z@4JA DD 09eH ; `WavePlayer::Play'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BG@MHLLCDAC@?$AAm?$AA_?$AAp?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@MHLLCDAC@?$AAm?$AA_?$AAp?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@ DB 'm'
	DB	00H, '_', 00H, 'p', 00H, 'D', 00H, 'e', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1JE@KOPMJDFJ@?$AAe?$AA?3?$AA?2?$AAm?$AAy?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAc?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?2?$AAp?$AAc?$AA2?$AA?4?$AA0?$AAt?$AAr?$AAu?$AAn?$AAk?$AA?2?$AAp?$AAc?$AA2?$AA?4@
CONST	SEGMENT
??_C@_1JE@KOPMJDFJ@?$AAe?$AA?3?$AA?2?$AAm?$AAy?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAc?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?2?$AAp?$AAc?$AA2?$AA?4?$AA0?$AAt?$AAr?$AAu?$AAn?$AAk?$AA?2?$AAp?$AAc?$AA2?$AA?4@ DB 'e'
	DB	00H, ':', 00H, '\', 00H, 'm', 00H, 'y', 00H, 'w', 00H, 'o', 00H
	DB	'r', 00H, 'k', 00H, '\', 00H, 'c', 00H, 'l', 00H, 'i', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, '\', 00H, 'p', 00H, 'c', 00H, '2', 00H
	DB	'.', 00H, '0', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'n', 00H, 'k'
	DB	00H, '\', 00H, 'p', 00H, 'c', 00H, '2', 00H, '.', 00H, '0', 00H
	DB	'\', 00H, 't', 00H, 'h', 00H, 'i', 00H, 'r', 00H, 'd', 00H, '_'
	DB	00H, 'p', 00H, 'a', 00H, 'r', 00H, 't', 00H, 'y', 00H, '\', 00H
	DB	'l', 00H, 'i', 00H, 'b', 00H, 'a', 00H, 'm', 00H, 'r', 00H, 'p'
	DB	00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H, '\', 00H
	DB	'w', 00H, 'a', 00H, 'v', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a'
	DB	00H, 'y', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c', 00H, 'p', 00H
	DB	'p', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@HAKCMIIN@?$AAm?$AA_?$AAh?$AAE?$AAv?$AAe?$AAn?$AAt?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@HAKCMIIN@?$AAm?$AA_?$AAh?$AAE?$AAv?$AAe?$AAn?$AAt?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$AA@ DB 'm'
	DB	00H, '_', 00H, 'h', 00H, 'E', 00H, 'v', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'D', 00H, 'e', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1???0WavePlayer@@QAE@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1???0WavePlayer@@QAE@XZ@4JA DD 010H	; `WavePlayer::WavePlayer'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ DB 'E'
	DB	00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R', 00H, ' ', 00H, ':', 00H
	DB	' ', 00H, 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'i', 00H, 'c', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 'A', 00H, 't', 00H, 'l', 00H, 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, 0aH
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA DD 020e1H ; `ATL::AtlWinModuleInit'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ DB 'E'
	DB	00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R', 00H, ' ', 00H, ':', 00H
	DB	' ', 00H, 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'i', 00H, 'c', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 'C', 00H, 'A', 00H, 't', 00H, 'l'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'M', 00H, 'o', 00H, 'd', 00H
	DB	'u', 00H, 'l', 00H, 'e', 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@LHJMKFAC@d?3?2program?5files?5?$CIx86?$CJ?2microsoft@
CONST	SEGMENT
??_C@_0FA@LHJMKFAC@d?3?2program?5files?5?$CIx86?$CJ?2microsoft@ DB 'd:\pr'
	DB	'ogram files (x86)\microsoft visual studio 12.0\vc\atlmfc\incl'
	DB	'ude\atlbase.h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KA@IOKHNBGA@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KA@IOKHNBGA@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'd'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, '.', 00H, 'h'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KC@IFBFKCIN@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KC@IFBFKCIN@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'd'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@
CONST	SEGMENT
??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@ DB 'f'
	DB	00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '"', 00H, 'T', 00H, 'o', 00H, 'o', 00H, ' '
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'f', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, 'd', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@ DB '%', 00H, 'S', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H
	DB	'%', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@ DB '%', 00H, 'u'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@ DB '%', 00H, 's'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'i'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm', 00H, 'p'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'v'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o'
	DB	00H, 'l', 00H, 's', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o', 00H, 'u'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1KC@PGLOMAAO@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KC@PGLOMAAO@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'd'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetAudioLength@WavePlayer@@QAEKPB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAudioLength@WavePlayer@@QAEKPB_W@Z$0
__ehfuncinfo$?GetAudioLength@WavePlayer@@QAEKPB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetAudioLength@WavePlayer@@QAEKPB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Play@WavePlayer@@QAEXPB_WPAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Play@WavePlayer@@QAEXPB_WPAK@Z$0
__ehfuncinfo$?Play@WavePlayer@@QAEXPB_WPAK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Play@WavePlayer@@QAEXPB_WPAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0WavePlayer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0WavePlayer@@QAE@XZ$0
__ehfuncinfo$??0WavePlayer@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0WavePlayer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CAtlWinModule@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CAtlWinModule@ATL@@QAE@XZ$0
__ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CAtlWinModule@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CAtlComModule@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CAtlComModule@ATL@@QAE@XZ$0
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CAtlComModule@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ$0
__ehfuncinfo$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0
__ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z$0
__ehfuncinfo$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceCOM$initializer$ DD FLAT:??__EatlTraceCOM@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceQI$initializer$ DD FLAT:??__EatlTraceQI@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceRegistrar$initializer$ DD FLAT:??__EatlTraceRegistrar@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceRefcount$initializer$ DD FLAT:??__EatlTraceRefcount@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceWindowing$initializer$ DD FLAT:??__EatlTraceWindowing@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceControls$initializer$ DD FLAT:??__EatlTraceControls@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceHosting$initializer$ DD FLAT:??__EatlTraceHosting@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceDBClient$initializer$ DD FLAT:??__EatlTraceDBClient@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceDBProvider$initializer$ DD FLAT:??__EatlTraceDBProvider@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceSnapin$initializer$ DD FLAT:??__EatlTraceSnapin@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceNotImpl$initializer$ DD FLAT:??__EatlTraceNotImpl@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceAllocation$initializer$ DD FLAT:??__EatlTraceAllocation@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceException$initializer$ DD FLAT:??__EatlTraceException@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceTime$initializer$ DD FLAT:??__EatlTraceTime@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceCache$initializer$ DD FLAT:??__EatlTraceCache@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceStencil$initializer$ DD FLAT:??__EatlTraceStencil@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceString$initializer$ DD FLAT:??__EatlTraceString@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceMap$initializer$ DD FLAT:??__EatlTraceMap@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceUtil$initializer$ DD FLAT:??__EatlTraceUtil@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceSecurity$initializer$ DD FLAT:??__EatlTraceSecurity@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceSync$initializer$ DD FLAT:??__EatlTraceSync@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceISAPI$initializer$ DD FLAT:??__EatlTraceISAPI@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
__AtlComModule$initializer$ DD FLAT:??__E_AtlComModule@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
__AtlWinModule$initializer$ DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00021	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00042	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00045	50		 push	 eax
  00046	6a 04		 push	 4
  00048	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004d	83 c4 08	 add	 esp, 8
  00050	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005d	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR $T3[ebp], 0
  00064	74 24		 je	 SHORT $LN3@construct
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  0006f	83 c4 04	 add	 esp, 4
  00072	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	89 02		 mov	 DWORD PTR [edx], eax
  0007c	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00082	89 8d 0c ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  00088	eb 0a		 jmp	 SHORT $LN4@construct
$LN3@construct:
  0008a	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
$LN4@construct:
  00094	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  0009a	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  000a0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000bb	3b ec		 cmp	 ebp, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00010	83 c4 08	 add	 esp, 8
  00013	c3		 ret	 0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	8b f4		 mov	 esi, esp
  00020	6a 00		 push	 0
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0id@locale@std@@QAE@I@Z
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	8b f4		 mov	 esi, esp
  00020	6a 00		 push	 0
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0id@locale@std@@QAE@I@Z
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00025	e8 00 00 00 00	 call	 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 731  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>

; 724  : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
  00023	e8 00 00 00 00	 call	 ??1_System_error_category@std@@UAE@XZ
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
  00023	e8 00 00 00 00	 call	 ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category
  00028	68 00 00 00 00	 push	 OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	83 c4 04	 add	 esp, 4
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
  00023	e8 00 00 00 00	 call	 ??1_Iostream_error_category@std@@UAE@XZ
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
  00023	e8 00 00 00 00	 call	 ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category
  00028	68 00 00 00 00	 push	 OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	83 c4 04	 add	 esp, 4
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
  00023	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
  00023	e8 00 00 00 00	 call	 ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category
  00028	68 00 00 00 00	 push	 OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	83 c4 04	 add	 esp, 4
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 23   : 	void *_Ptr = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00029	75 02		 jne	 SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

  0002b	eb 2a		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0002d	83 7d 08 ff	 cmp	 DWORD PTR __Count$[ebp], -1
  00031	77 15		 ja	 SHORT $LN1@Allocate
  00033	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  00042	83 7d f8 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00046	75 0f		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00048	8b f4		 mov	 esi, esp
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  00057	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 23   : 	void *_Ptr = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00029	75 02		 jne	 SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

  0002b	eb 30		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0002d	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00034	77 18		 ja	 SHORT $LN1@Allocate
  00036	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00039	c1 e0 03	 shl	 eax, 3
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  00048	83 7d f8 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0004c	75 0f		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0004e	8b f4		 mov	 esi, esp
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00056	3b f4		 cmp	 esi, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0005d	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00021	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00042	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00045	50		 push	 eax
  00046	6a 08		 push	 8
  00048	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004d	83 c4 08	 add	 esp, 8
  00050	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005d	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR $T3[ebp], 0
  00064	74 2a		 je	 SHORT $LN3@construct
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  0006f	83 c4 04	 add	 esp, 4
  00072	8b 10		 mov	 edx, DWORD PTR [eax]
  00074	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00077	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  0007d	89 11		 mov	 DWORD PTR [ecx], edx
  0007f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00082	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  00088	89 95 0c ff ff
	ff		 mov	 DWORD PTR tv74[ebp], edx
  0008e	eb 0a		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00090	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  0009a	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]
  000a0	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  000a6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

  000ad	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b7	59		 pop	 ecx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00010	83 c4 08	 add	 esp, 8
  00013	c3		 ret	 0
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00023	6a 00		 push	 0
  00025	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
  0002e	83 c4 08	 add	 esp, 8

; 579  : 		}

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002c	83 c4 04	 add	 esp, 4

; 574  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ PROC	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ENDP	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
  00030	83 c4 08	 add	 esp, 8

; 880  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

  00023	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 873  : 		}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_System_error_category@std@@UAE@XZ
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0c		 je	 SHORT $LN1@scalar
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN1@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 614  : 		{	// make error_condition for error code (generic if possible)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 615  : 		if (_Syserror_map(_Errval))

  00023	8b f4		 mov	 esi, esp
  00025	8b 45 0c	 mov	 eax, DWORD PTR __Errval$[ebp]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
  0002f	83 c4 04	 add	 esp, 4
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $LN2@default_er

; 616  : 			return (error_condition(_Errval, generic_category()));

  0003d	e8 00 00 00 00	 call	 ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
  00042	50		 push	 eax
  00043	8b 45 0c	 mov	 eax, DWORD PTR __Errval$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004a	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  0004f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00052	eb 17		 jmp	 SHORT $LN3@default_er

; 617  : 		else

  00054	eb 15		 jmp	 SHORT $LN3@default_er
$LN2@default_er:

; 618  : 			return (error_condition(_Errval, system_category()));

  00056	e8 00 00 00 00	 call	 ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
  0005b	50		 push	 eax
  0005c	8b 45 0c	 mov	 eax, DWORD PTR __Errval$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00063	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  00068	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 619  : 		}

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 607  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

  0002d	8b f4		 mov	 esi, esp
  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Winerror_map@std@@YAPBDH@Z
  00039	83 c4 04	 add	 esp, 4
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	89 45 ec	 mov	 DWORD PTR __Name$[ebp], eax

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

  00046	83 7d ec 00	 cmp	 DWORD PTR __Name$[ebp], 0
  0004a	74 0b		 je	 SHORT $LN3@message
  0004c	8b 45 ec	 mov	 eax, DWORD PTR __Name$[ebp]
  0004f	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  00055	eb 0a		 jmp	 SHORT $LN4@message
$LN3@message:
  00057	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
  00061	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  00067	51		 push	 ecx
  00068	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0006b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00070	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00076	83 ca 01	 or	 edx, 1
  00079	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 610  : 		}

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 602  : 		{	// get name of category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 603  : 		return ("system");

  00023	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 604  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 597  : 	_System_error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 598  : 		{	// default constructor
; 599  : 		}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Iostream_error_category@std@@UAE@XZ
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0c		 je	 SHORT $LN1@scalar
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN1@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 584  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 585  : 		if (_Errcode == (int)io_errc::stream)

  0002d	83 7d 0c 01	 cmp	 DWORD PTR __Errcode$[ebp], 1
  00031	75 23		 jne	 SHORT $LN2@message

; 586  : 			return ("iostream stream error");

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
  00038	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00040	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00046	83 c8 01	 or	 eax, 1
  00049	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0004f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00052	eb 24		 jmp	 SHORT $LN3@message

; 587  : 		else

  00054	eb 22		 jmp	 SHORT $LN3@message
$LN2@message:

; 588  : 			return (_Generic_error_category::message(_Errcode));

  00056	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
  00066	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0006c	83 ca 01	 or	 edx, 1
  0006f	89 95 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  00075	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 589  : 		}

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 579  : 		{	// get name of category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		return ("iostream");

  00023	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 581  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 574  : 	_Iostream_error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 575  : 		{	// default constructor
; 576  : 		}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0c		 je	 SHORT $LN1@scalar
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN1@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1error_category@std@@UAE@XZ ; std::error_category::~error_category
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 563  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

  0002d	8b f4		 mov	 esi, esp
  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
  00039	83 c4 04	 add	 esp, 4
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	89 45 ec	 mov	 DWORD PTR __Name$[ebp], eax

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

  00046	83 7d ec 00	 cmp	 DWORD PTR __Name$[ebp], 0
  0004a	74 0b		 je	 SHORT $LN3@message
  0004c	8b 45 ec	 mov	 eax, DWORD PTR __Name$[ebp]
  0004f	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  00055	eb 0a		 jmp	 SHORT $LN4@message
$LN3@message:
  00057	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
  00061	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  00067	51		 push	 ecx
  00068	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0006b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00070	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00076	83 ca 01	 or	 edx, 1
  00079	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 566  : 		}

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 558  : 		{	// get name of category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 559  : 		return ("generic");

  00023	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 560  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 553  : 	_Generic_error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0error_category@std@@QAE@XZ ; std::error_category::error_category
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 554  : 		{	// default constructor
; 555  : 		}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 352  : 		{	// test if *this == _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00026	e8 00 00 00 00	 call	 ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
  0002b	50		 push	 eax
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	85 c0		 test	 eax, eax
  00040	74 22		 je	 SHORT $LN3@operator
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?value@error_condition@std@@QBEHXZ ; std::error_condition::value
  0004a	8b f0		 mov	 esi, eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004f	e8 00 00 00 00	 call	 ?value@error_condition@std@@QBEHXZ ; std::error_condition::value
  00054	3b f0		 cmp	 esi, eax
  00056	75 0c		 jne	 SHORT $LN3@operator
  00058	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv78[ebp], 1
  00062	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00064	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
$LN4@operator:
  0006e	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv78[ebp]

; 355  : 		}

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 337  : 		{	// get category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		return (*_Mycat);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 339  : 		}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 332  : 		{	// get error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 333  : 		return (_Myval);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]

; 334  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 299  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR __Cat$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 300  : 		}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 246  : 		{	// get category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 247  : 		return (*_Mycat);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 248  : 		}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 241  : 		{	// get error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 242  : 		return (_Myval);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]

; 243  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1error_category@std@@UAE@XZ ; std::error_category::~error_category
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0c		 je	 SHORT $LN1@scalar
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN1@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 176  : 		{	// compare categories for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 177  : 		return (this == &_Right);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00029	75 0c		 jne	 SHORT $LN3@operator
  0002b	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv65[ebp], 1
  00035	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00037	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv65[ebp], 0
$LN4@operator:
  00041	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv65[ebp]

; 178  : 		}

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 391  : 	{	// test if conditions same for this category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Code$[ebp]
  00026	e8 00 00 00 00	 call	 ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
  0002b	50		 push	 eax
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==
  00034	0f b6 c0	 movzx	 eax, al
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $LN3@equivalent
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Code$[ebp]
  0003e	e8 00 00 00 00	 call	 ?value@error_code@std@@QBEHXZ ; std::error_code::value
  00043	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  00046	75 0c		 jne	 SHORT $LN3@equivalent
  00048	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv74[ebp], 1
  00052	eb 0a		 jmp	 SHORT $LN4@equivalent
$LN3@equivalent:
  00054	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
$LN4@equivalent:
  0005e	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv74[ebp]

; 393  : 	}

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 384  : 	{	// test if error code same condition

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 385  : 	return (default_error_condition(_Errval) == _Cond);

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Cond$[ebp]
  00026	50		 push	 eax
  00027	8b f4		 mov	 esi, esp
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Errval$[ebp]
  0002c	51		 push	 ecx
  0002d	8d 95 28 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00033	52		 push	 edx
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 10		 mov	 edx, DWORD PTR [eax]
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0003f	ff d0		 call	 eax
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b c8		 mov	 ecx, eax
  0004a	e8 00 00 00 00	 call	 ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==

; 386  : 	}

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 377  : 	{	// make error_condition for error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 378  : 	return (error_condition(_Errval, *this));

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR __Errval$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  00033	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 379  : 	}

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 160  : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 154  : 	error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 155  : 		{	// default constructor
; 156  : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 652  : 	{	// get system_category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 653  : 	return (_Error_objects<int>::_System_object);

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 654  : 	}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 642  : 	{	// get generic_category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 643  : 	return (_Error_objects<int>::_Generic_object);

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 644  : 	}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z PROC		; std::_Debug_pointer<char>, COMDAT

; 545  : 	{	// test iterator for non-singularity, const pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 546  : 	if (_First == 0)

  0001e	83 7d 08 00	 cmp	 DWORD PTR __First$[ebp], 0
  00022	75 1f		 jne	 SHORT $LN2@Debug_poin

; 547  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

  00024	8b f4		 mov	 esi, esp
  00026	8b 45 10	 mov	 eax, DWORD PTR __Line$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR __File$[ebp]
  0002d	51		 push	 ecx
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Debug_poin:

; 548  : 	}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ENDP		; std::_Debug_pointer<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?OnPlayFinished@WavePlayer@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?OnPlayFinished@WavePlayer@@IAEXXZ PROC			; WavePlayer::OnPlayFinished, COMDAT
; _this$ = ecx

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 549  : 	m_ePlayStat = Play_Stop;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 550  : 
; 551  : 	if (m_soundCB)

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  00034	74 23		 je	 SHORT $LN2@OnPlayFini

; 552  : 		m_soundCB->onSoundPlayed(m_cbData);

  00036	8b f4		 mov	 esi, esp
  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0003e	51		 push	 ecx
  0003f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 10		 mov	 edx, DWORD PTR [eax]
  0004a	8b 49 68	 mov	 ecx, DWORD PTR [ecx+104]
  0004d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00050	ff d0		 call	 eax
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@OnPlayFini:

; 553  : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?OnPlayFinished@WavePlayer@@IAEXXZ ENDP			; WavePlayer::OnPlayFinished
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?UnInit@WavePlayer@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?UnInit@WavePlayer@@IAEXXZ PROC				; WavePlayer::UnInit, COMDAT
; _this$ = ecx

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 109  :     if(m_hThreadPlay)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	74 6b		 je	 SHORT $LN4@UnInit

; 110  :     {
; 111  :         // 
; 112  :         EnterCriticalSection( &m_cs );

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c0 50	 add	 eax, 80			; 00000050H
  00031	8b f4		 mov	 esi, esp
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 113  :         m_msgPlayThread = TMSG_CLOSE;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 114  :         LeaveCriticalSection( &m_cs );

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 c0 50	 add	 eax, 80			; 00000050H
  00051	8b f4		 mov	 esi, esp
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0005a	3b f4		 cmp	 esi, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 115  :         WaitForSingleObject(m_hThreadPlay, INFINITE);

  00061	8b f4		 mov	 esi, esp
  00063	6a ff		 push	 -1
  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	51		 push	 ecx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 116  : 
; 117  :         CloseHandle(m_hThreadPlay);

  00078	8b f4		 mov	 esi, esp
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	51		 push	 ecx
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00086	3b f4		 cmp	 esi, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 118  :         m_hThreadPlay = NULL;

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00090	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN4@UnInit:

; 119  :     }
; 120  : 
; 121  :     if(m_hThreadDecode)

  00096	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0009d	74 6e		 je	 SHORT $LN3@UnInit

; 122  :     {
; 123  :         // 
; 124  :         EnterCriticalSection( &m_cs );

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	83 c0 50	 add	 eax, 80			; 00000050H
  000a5	8b f4		 mov	 esi, esp
  000a7	50		 push	 eax
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  000ae	3b f4		 cmp	 esi, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 125  :         m_msgDecodeThread = TMSG_CLOSE;

  000b5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 126  :         LeaveCriticalSection( &m_cs );

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	83 c0 50	 add	 eax, 80			; 00000050H
  000c5	8b f4		 mov	 esi, esp
  000c7	50		 push	 eax
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 127  :         WaitForSingleObject(m_hThreadDecode, INFINITE);

  000d5	8b f4		 mov	 esi, esp
  000d7	6a ff		 push	 -1
  000d9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000df	51		 push	 ecx
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  000e6	3b f4		 cmp	 esi, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 128  : 
; 129  :         CloseHandle(m_hThreadDecode);

  000ed	8b f4		 mov	 esi, esp
  000ef	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	51		 push	 ecx
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  000fc	3b f4		 cmp	 esi, esp
  000fe	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 130  :         m_hThreadDecode = NULL;

  00103	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00106	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN3@UnInit:

; 131  :     }
; 132  : 
; 133  :     // 
; 134  :     if(m_waveData.pData)

  0010d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00110	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00114	74 32		 je	 SHORT $LN2@UnInit

; 135  :     {
; 136  :         HeapFree(GetProcessHeap(), 0, m_waveData.pData);

  00116	8b f4		 mov	 esi, esp
  00118	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0011e	51		 push	 ecx
  0011f	6a 00		 push	 0
  00121	8b fc		 mov	 edi, esp
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00129	3b fc		 cmp	 edi, esp
  0012b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00130	50		 push	 eax
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12
  00137	3b f4		 cmp	 esi, esp
  00139	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 137  :         m_waveData.pData = NULL;

  0013e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00141	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN2@UnInit:

; 138  :     }
; 139  :     memset(&m_waveData, 0, sizeof(WaveData));

  00148	6a 20		 push	 32			; 00000020H
  0014a	6a 00		 push	 0
  0014c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0014f	83 c0 24	 add	 eax, 36			; 00000024H
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 _memset
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH

; 140  : 
; 141  :     // 
; 142  :     if(m_hWaveoutDev)

  0015b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0015e	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00162	74 36		 je	 SHORT $LN1@UnInit

; 143  :     {
; 144  :         waveOutReset(m_hWaveoutDev);

  00164	8b f4		 mov	 esi, esp
  00166	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00169	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0016c	51		 push	 ecx
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutReset@4
  00173	3b f4		 cmp	 esi, esp
  00175	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 145  :         waveOutClose(m_hWaveoutDev);

  0017a	8b f4		 mov	 esi, esp
  0017c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0017f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00182	51		 push	 ecx
  00183	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutClose@4
  00189	3b f4		 cmp	 esi, esp
  0018b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 146  :         m_hWaveoutDev = NULL;

  00190	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00193	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN1@UnInit:

; 147  :     }
; 148  :     
; 149  :     // 
; 150  :     m_wBlock.wfreeblock = BLOCK_COUNT;

  0019a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0019d	c7 40 1c 14 00
	00 00		 mov	 DWORD PTR [eax+28], 20	; 00000014H

; 151  :     m_wBlock.wcurrblock = 0;

  001a4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a7	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 152  :     m_wBlock.wpos       = 0;

  001ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001b1	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 153  : 
; 154  :     m_ePlayStat         = Play_Stop;

  001b8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001bb	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 155  : }

  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi
  001c4	5b		 pop	 ebx
  001c5	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  001cb	3b ec		 cmp	 ebp, esp
  001cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d2	8b e5		 mov	 esp, ebp
  001d4	5d		 pop	 ebp
  001d5	c3		 ret	 0
?UnInit@WavePlayer@@IAEXXZ ENDP				; WavePlayer::UnInit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?freeBlocks@WavePlayer@@IAEXPAUwavehdr_tag@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_blockArray$ = 8					; size = 4
?freeBlocks@WavePlayer@@IAEXPAUwavehdr_tag@@@Z PROC	; WavePlayer::freeBlocks, COMDAT
; _this$ = ecx

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 104  :     HeapFree(GetProcessHeap(), 0, blockArray);

  00023	8b f4		 mov	 esi, esp
  00025	8b 45 08	 mov	 eax, DWORD PTR _blockArray$[ebp]
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 105  : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?freeBlocks@WavePlayer@@IAEXPAUwavehdr_tag@@@Z ENDP	; WavePlayer::freeBlocks
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?allocBlocks@WavePlayer@@IAEPAUwavehdr_tag@@HH@Z
_TEXT	SEGMENT
_totalBufferSize$ = -56					; size = 4
_blocks$ = -44						; size = 4
_i$ = -32						; size = 4
_buffer$ = -20						; size = 4
_this$ = -8						; size = 4
_size$ = 8						; size = 4
_count$ = 12						; size = 4
?allocBlocks@WavePlayer@@IAEPAUwavehdr_tag@@HH@Z PROC	; WavePlayer::allocBlocks, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00013	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 73   :     unsigned char* buffer;
; 74   :     int i;
; 75   :     WAVEHDR* blocks;
; 76   :     DWORD totalBufferSize = (size + sizeof(WAVEHDR)) * count;

  00023	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00026	83 c0 20	 add	 eax, 32			; 00000020H
  00029	0f af 45 0c	 imul	 eax, DWORD PTR _count$[ebp]
  0002d	89 45 c8	 mov	 DWORD PTR _totalBufferSize$[ebp], eax

; 77   : 
; 78   :     //  
; 79   :     if((buffer = ( UCHAR*) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, totalBufferSize )) == NULL)	

  00030	8b f4		 mov	 esi, esp
  00032	8b 45 c8	 mov	 eax, DWORD PTR _totalBufferSize$[ebp]
  00035	50		 push	 eax
  00036	6a 08		 push	 8
  00038	8b fc		 mov	 edi, esp
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00040	3b fc		 cmp	 edi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	89 45 ec	 mov	 DWORD PTR _buffer$[ebp], eax
  00058	83 7d ec 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  0005c	75 04		 jne	 SHORT $LN4@allocBlock

; 80   :         return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	eb 59		 jmp	 SHORT $LN5@allocBlock
$LN4@allocBlock:

; 81   : 
; 82   :     // 
; 83   :     blocks = (WAVEHDR*)buffer;

  00062	8b 45 ec	 mov	 eax, DWORD PTR _buffer$[ebp]
  00065	89 45 d4	 mov	 DWORD PTR _blocks$[ebp], eax

; 84   :     buffer += sizeof(WAVEHDR) * count;

  00068	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  0006b	c1 e0 05	 shl	 eax, 5
  0006e	03 45 ec	 add	 eax, DWORD PTR _buffer$[ebp]
  00071	89 45 ec	 mov	 DWORD PTR _buffer$[ebp], eax

; 85   :     for(i = 0; i < count; i++) 

  00074	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007b	eb 09		 jmp	 SHORT $LN3@allocBlock
$LN2@allocBlock:
  0007d	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN3@allocBlock:
  00086	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00089	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  0008c	7d 2a		 jge	 SHORT $LN1@allocBlock

; 86   :     {
; 87   :         blocks[i].dwBufferLength = size;

  0008e	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00091	c1 e0 05	 shl	 eax, 5
  00094	8b 4d d4	 mov	 ecx, DWORD PTR _blocks$[ebp]
  00097	8b 55 08	 mov	 edx, DWORD PTR _size$[ebp]
  0009a	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx

; 88   :         blocks[i].lpData = (CHAR *)buffer;

  0009e	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000a1	c1 e0 05	 shl	 eax, 5
  000a4	8b 4d d4	 mov	 ecx, DWORD PTR _blocks$[ebp]
  000a7	8b 55 ec	 mov	 edx, DWORD PTR _buffer$[ebp]
  000aa	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 89   :         buffer += size;

  000ad	8b 45 ec	 mov	 eax, DWORD PTR _buffer$[ebp]
  000b0	03 45 08	 add	 eax, DWORD PTR _size$[ebp]
  000b3	89 45 ec	 mov	 DWORD PTR _buffer$[ebp], eax

; 90   :     }

  000b6	eb c5		 jmp	 SHORT $LN2@allocBlock
$LN1@allocBlock:

; 91   : 
; 92   :     return blocks;

  000b8	8b 45 d4	 mov	 eax, DWORD PTR _blocks$[ebp]
$LN5@allocBlock:

; 93   : }

  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  000c4	3b ec		 cmp	 ebp, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 08 00	 ret	 8
?allocBlocks@WavePlayer@@IAEPAUwavehdr_tag@@HH@Z ENDP	; WavePlayer::allocBlocks
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?DecodeThreadProcImpl@WavePlayer@@IAEIXZ
_TEXT	SEGMENT
_dwSize$1 = -68						; size = 4
_dwSizeAmount$ = -56					; size = 4
_tmsg$ = -44						; size = 4
_pBufferBase$ = -32					; size = 4
_dwFrameMaxSize$ = -20					; size = 4
_this$ = -8						; size = 4
?DecodeThreadProcImpl@WavePlayer@@IAEIXZ PROC		; WavePlayer::DecodeThreadProcImpl, COMDAT
; _this$ = ecx

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00013	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 473  :     if(m_pDecoder == NULL || !m_pDecoder->IsVaild())

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  0002a	74 23		 je	 SHORT $LN7@DecodeThre
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00032	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	8b f4		 mov	 esi, esp
  00039	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  0003c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0003f	ff d2		 call	 edx
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	75 1d		 jne	 SHORT $LN8@DecodeThre
$LN7@DecodeThre:

; 474  : 	{
; 475  : 		SetEvent(m_hEventDecode);

  0004f	8b f4		 mov	 esi, esp
  00051	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00057	51		 push	 ecx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 476  :         return 0;

  00065	33 c0		 xor	 eax, eax
  00067	e9 63 02 00 00	 jmp	 $LN9@DecodeThre
$LN8@DecodeThre:

; 477  : 	}
; 478  : 
; 479  :     // 
; 480  :     if(!m_pDecoder->BeginDecode())

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00072	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00075	8b 01		 mov	 eax, DWORD PTR [ecx]
  00077	8b f4		 mov	 esi, esp
  00079	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  0007c	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0007f	ff d2		 call	 edx
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	85 c0		 test	 eax, eax
  0008a	75 1d		 jne	 SHORT $LN6@DecodeThre

; 481  :     {
; 482  : 		SetEvent(m_hEventDecode);

  0008c	8b f4		 mov	 esi, esp
  0008e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00091	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00094	51		 push	 ecx
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  0009b	3b f4		 cmp	 esi, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 483  :         return 0;

  000a2	33 c0		 xor	 eax, eax
  000a4	e9 26 02 00 00	 jmp	 $LN9@DecodeThre
$LN6@DecodeThre:

; 484  :     }
; 485  : 
; 486  :     // 
; 487  :     DWORD dwFrameMaxSize = m_pDecoder->GetDecodedFrameMaxSize();

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000af	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b4	8b f4		 mov	 esi, esp
  000b6	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  000b9	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  000bc	ff d2		 call	 edx
  000be	3b f4		 cmp	 esi, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	89 45 ec	 mov	 DWORD PTR _dwFrameMaxSize$[ebp], eax

; 488  :     LPSTR pBufferBase = (LPSTR)malloc(dwFrameMaxSize);

  000c8	8b f4		 mov	 esi, esp
  000ca	8b 45 ec	 mov	 eax, DWORD PTR _dwFrameMaxSize$[ebp]
  000cd	50		 push	 eax
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000d4	83 c4 04	 add	 esp, 4
  000d7	3b f4		 cmp	 esi, esp
  000d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000de	89 45 e0	 mov	 DWORD PTR _pBufferBase$[ebp], eax

; 489  :     ATLASSERT(pBufferBase);

  000e1	83 7d e0 00	 cmp	 DWORD PTR _pBufferBase$[ebp], 0
  000e5	75 34		 jne	 SHORT $LN11@DecodeThre
  000e7	8b f4		 mov	 esi, esp
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@LPCBEODC@?$AAp?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAB?$AAa?$AAs?$AAe?$AA?$AA@
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  000f3	6a 00		 push	 0
  000f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??DecodeThreadProcImpl@WavePlayer@@IAEIXZ@4JA
  000fa	83 c0 11	 add	 eax, 17			; 00000011H
  000fd	50		 push	 eax
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_1JE@KOPMJDFJ@?$AAe?$AA?3?$AA?2?$AAm?$AAy?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAc?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?2?$AAp?$AAc?$AA2?$AA?4?$AA0?$AAt?$AAr?$AAu?$AAn?$AAk?$AA?2?$AAp?$AAc?$AA2?$AA?4@
  00103	6a 02		 push	 2
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0010b	83 c4 18	 add	 esp, 24			; 00000018H
  0010e	3b f4		 cmp	 esi, esp
  00110	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00115	83 f8 01	 cmp	 eax, 1
  00118	75 01		 jne	 SHORT $LN11@DecodeThre
  0011a	cc		 int	 3
$LN11@DecodeThre:

; 490  :     memset(pBufferBase, 0, dwFrameMaxSize);

  0011b	8b 45 ec	 mov	 eax, DWORD PTR _dwFrameMaxSize$[ebp]
  0011e	50		 push	 eax
  0011f	6a 00		 push	 0
  00121	8b 4d e0	 mov	 ecx, DWORD PTR _pBufferBase$[ebp]
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 _memset
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 491  :     if(pBufferBase == NULL) return 0;

  0012d	83 7d e0 00	 cmp	 DWORD PTR _pBufferBase$[ebp], 0
  00131	75 07		 jne	 SHORT $LN5@DecodeThre
  00133	33 c0		 xor	 eax, eax
  00135	e9 95 01 00 00	 jmp	 $LN9@DecodeThre
$LN5@DecodeThre:

; 492  : 
; 493  :     register ThreadMsg tmsg = TMSG_ALIVE;

  0013a	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _tmsg$[ebp], 1

; 494  : 
; 495  :     DWORD dwSizeAmount = 0;

  00141	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _dwSizeAmount$[ebp], 0
$LN4@DecodeThre:

; 496  :     while(!m_pDecoder->IsEOF() && tmsg)

  00148	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0014e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	8b f4		 mov	 esi, esp
  00155	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  00158	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0015b	ff d2		 call	 edx
  0015d	3b f4		 cmp	 esi, esp
  0015f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00164	0f b6 c0	 movzx	 eax, al
  00167	85 c0		 test	 eax, eax
  00169	0f 85 ff 00 00
	00		 jne	 $LN3@DecodeThre
  0016f	83 7d d4 00	 cmp	 DWORD PTR _tmsg$[ebp], 0
  00173	0f 84 f5 00 00
	00		 je	 $LN3@DecodeThre

; 497  :     {
; 498  :         // 
; 499  :         DWORD dwSize = m_pDecoder->Decode(pBufferBase);

  00179	8b f4		 mov	 esi, esp
  0017b	8d 45 e0	 lea	 eax, DWORD PTR _pBufferBase$[ebp]
  0017e	50		 push	 eax
  0017f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00185	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00188	8b 12		 mov	 edx, DWORD PTR [edx]
  0018a	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0018d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00190	ff d0		 call	 eax
  00192	3b f4		 cmp	 esi, esp
  00194	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00199	89 45 bc	 mov	 DWORD PTR _dwSize$1[ebp], eax

; 500  :         dwSizeAmount += dwSize;

  0019c	8b 45 c8	 mov	 eax, DWORD PTR _dwSizeAmount$[ebp]
  0019f	03 45 bc	 add	 eax, DWORD PTR _dwSize$1[ebp]
  001a2	89 45 c8	 mov	 DWORD PTR _dwSizeAmount$[ebp], eax

; 501  : 
; 502  :         // 
; 503  :         EnterCriticalSection(&m_cs);           

  001a5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a8	83 c0 50	 add	 eax, 80			; 00000050H
  001ab	8b f4		 mov	 esi, esp
  001ad	50		 push	 eax
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  001b4	3b f4		 cmp	 esi, esp
  001b6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 504  :         memcpy(m_waveData.pData + m_waveData.dwSize, pBufferBase, dwSize);

  001bb	8b 45 bc	 mov	 eax, DWORD PTR _dwSize$1[ebp]
  001be	50		 push	 eax
  001bf	8b 4d e0	 mov	 ecx, DWORD PTR _pBufferBase$[ebp]
  001c2	51		 push	 ecx
  001c3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001c6	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  001c9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cc	03 41 3c	 add	 eax, DWORD PTR [ecx+60]
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 _memcpy
  001d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 505  :         m_waveData.dwSize += dwSize;

  001d8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001db	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  001de	03 4d bc	 add	 ecx, DWORD PTR _dwSize$1[ebp]
  001e1	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001e4	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 506  :         LeaveCriticalSection(&m_cs);

  001e7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001ea	83 c0 50	 add	 eax, 80			; 00000050H
  001ed	8b f4		 mov	 esi, esp
  001ef	50		 push	 eax
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  001f6	3b f4		 cmp	 esi, esp
  001f8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 507  : 
; 508  :         // 
; 509  :         if(dwSizeAmount > BLOCK_SIZE)

  001fd	81 7d c8 a0 0f
	00 00		 cmp	 DWORD PTR _dwSizeAmount$[ebp], 4000 ; 00000fa0H
  00204	76 1d		 jbe	 SHORT $LN2@DecodeThre

; 510  :         {
; 511  :             dwSizeAmount = 0;

  00206	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _dwSizeAmount$[ebp], 0

; 512  :             SetEvent(m_hEventDecode);

  0020d	8b f4		 mov	 esi, esp
  0020f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00212	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00215	51		 push	 ecx
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  0021c	3b f4		 cmp	 esi, esp
  0021e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@DecodeThre:

; 513  :         }
; 514  : 
; 515  :         // CPUCPU
; 516  :         Sleep(1);

  00223	8b f4		 mov	 esi, esp
  00225	6a 01		 push	 1
  00227	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0022d	3b f4		 cmp	 esi, esp
  0022f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 517  : 
; 518  :         // 
; 519  :         EnterCriticalSection(&m_cs);

  00234	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00237	83 c0 50	 add	 eax, 80			; 00000050H
  0023a	8b f4		 mov	 esi, esp
  0023c	50		 push	 eax
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00243	3b f4		 cmp	 esi, esp
  00245	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 520  :         tmsg = m_msgDecodeThread;

  0024a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0024d	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00250	89 4d d4	 mov	 DWORD PTR _tmsg$[ebp], ecx

; 521  :         LeaveCriticalSection(&m_cs);

  00253	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00256	83 c0 50	 add	 eax, 80			; 00000050H
  00259	8b f4		 mov	 esi, esp
  0025b	50		 push	 eax
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00262	3b f4		 cmp	 esi, esp
  00264	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 522  :     }

  00269	e9 da fe ff ff	 jmp	 $LN4@DecodeThre
$LN3@DecodeThre:

; 523  : 
; 524  :     // 
; 525  :     if(dwSizeAmount > 0)

  0026e	83 7d c8 00	 cmp	 DWORD PTR _dwSizeAmount$[ebp], 0
  00272	76 16		 jbe	 SHORT $LN1@DecodeThre

; 526  :     {
; 527  :         SetEvent(m_hEventDecode);

  00274	8b f4		 mov	 esi, esp
  00276	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00279	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0027c	51		 push	 ecx
  0027d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  00283	3b f4		 cmp	 esi, esp
  00285	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@DecodeThre:

; 528  :     }
; 529  : 
; 530  :     m_waveData.bDecodeFinished = true;

  0028a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0028d	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [eax+64], 1

; 531  : 
; 532  :     // 
; 533  :     m_pDecoder->EndDecode();

  00294	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00297	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0029a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0029d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0029f	8b f4		 mov	 esi, esp
  002a1	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  002a4	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  002a7	ff d2		 call	 edx
  002a9	3b f4		 cmp	 esi, esp
  002ab	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 534  : 
; 535  :     free(pBufferBase);

  002b0	8b f4		 mov	 esi, esp
  002b2	8b 45 e0	 mov	 eax, DWORD PTR _pBufferBase$[ebp]
  002b5	50		 push	 eax
  002b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  002bc	83 c4 04	 add	 esp, 4
  002bf	3b f4		 cmp	 esi, esp
  002c1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 536  :     pBufferBase = NULL;

  002c6	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pBufferBase$[ebp], 0

; 537  : 
; 538  :     return 0;

  002cd	33 c0		 xor	 eax, eax
$LN9@DecodeThre:

; 539  : }

  002cf	52		 push	 edx
  002d0	8b cd		 mov	 ecx, ebp
  002d2	50		 push	 eax
  002d3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@DecodeThre
  002d9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002de	58		 pop	 eax
  002df	5a		 pop	 edx
  002e0	5f		 pop	 edi
  002e1	5e		 pop	 esi
  002e2	5b		 pop	 ebx
  002e3	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  002e9	3b ec		 cmp	 ebp, esp
  002eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002f0	8b e5		 mov	 esp, ebp
  002f2	5d		 pop	 ebp
  002f3	c3		 ret	 0
$LN14@DecodeThre:
  002f4	01 00 00 00	 DD	 1
  002f8	00 00 00 00	 DD	 $LN13@DecodeThre
$LN13@DecodeThre:
  002fc	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00300	04 00 00 00	 DD	 4
  00304	00 00 00 00	 DD	 $LN12@DecodeThre
$LN12@DecodeThre:
  00308	70		 DB	 112			; 00000070H
  00309	42		 DB	 66			; 00000042H
  0030a	75		 DB	 117			; 00000075H
  0030b	66		 DB	 102			; 00000066H
  0030c	66		 DB	 102			; 00000066H
  0030d	65		 DB	 101			; 00000065H
  0030e	72		 DB	 114			; 00000072H
  0030f	42		 DB	 66			; 00000042H
  00310	61		 DB	 97			; 00000061H
  00311	73		 DB	 115			; 00000073H
  00312	65		 DB	 101			; 00000065H
  00313	00		 DB	 0
?DecodeThreadProcImpl@WavePlayer@@IAEIXZ ENDP		; WavePlayer::DecodeThreadProcImpl
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?DecodeThread@WavePlayer@@KGIPAX@Z
_TEXT	SEGMENT
_pThis$ = -8						; size = 4
_lp$ = 8						; size = 4
?DecodeThread@WavePlayer@@KGIPAX@Z PROC			; WavePlayer::DecodeThread, COMDAT

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 466  :     WavePlayer* pThis = (WavePlayer*)lp;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _lp$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _pThis$[ebp], eax

; 467  : 
; 468  :     return pThis->DecodeThreadProcImpl();

  00024	8b 4d f8	 mov	 ecx, DWORD PTR _pThis$[ebp]
  00027	e8 00 00 00 00	 call	 ?DecodeThreadProcImpl@WavePlayer@@IAEIXZ ; WavePlayer::DecodeThreadProcImpl

; 469  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?DecodeThread@WavePlayer@@KGIPAX@Z ENDP			; WavePlayer::DecodeThread
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?PlayThreadProcImpl@WavePlayer@@IAEIXZ
_TEXT	SEGMENT
_j$1 = -140						; size = 4
_j$2 = -128						; size = 4
_free$3 = -116						; size = 4
_chunk$4 = -104						; size = 4
_bDecodeFinished$5 = -92				; size = 4
_left$6 = -80						; size = 4
_m$7 = -68						; size = 4
_current$8 = -56					; size = 4
_free$9 = -44						; size = 4
_mmres$10 = -32						; size = 4
_tmsg$ = -20						; size = 4
_this$ = -8						; size = 4
?PlayThreadProcImpl@WavePlayer@@IAEIXZ PROC		; WavePlayer::PlayThreadProcImpl, COMDAT
; _this$ = ecx

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd b0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-336]
  00013	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 299  :     /// 
; 300  :     register    ThreadMsg       tmsg  = TMSG_ALIVE;         

  00023	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _tmsg$[ebp], 1
$LN26@PlayThread:

; 301  : 
; 302  :     /// 
; 303  :     while( tmsg )

  0002a	83 7d ec 00	 cmp	 DWORD PTR _tmsg$[ebp], 0
  0002e	0f 84 92 03 00
	00		 je	 $LN25@PlayThread

; 304  :     {
; 305  :         // CPUcontinue
; 306  :         Sleep(10);

  00034	8b f4		 mov	 esi, esp
  00036	6a 0a		 push	 10			; 0000000aH
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 307  : 
; 308  :         /// 
; 309  :         EnterCriticalSection( &m_cs );

  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	83 c0 50	 add	 eax, 80			; 00000050H
  0004b	8b f4		 mov	 esi, esp
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 310  :         tmsg = m_msgPlayThread;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00061	89 4d ec	 mov	 DWORD PTR _tmsg$[ebp], ecx

; 311  :         LeaveCriticalSection( &m_cs );

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 c0 50	 add	 eax, 80			; 00000050H
  0006a	8b f4		 mov	 esi, esp
  0006c	50		 push	 eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00073	3b f4		 cmp	 esi, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 312  :         // 
; 313  :         if(!tmsg)   break;

  0007a	83 7d ec 00	 cmp	 DWORD PTR _tmsg$[ebp], 0
  0007e	75 05		 jne	 SHORT $LN24@PlayThread
  00080	e9 41 03 00 00	 jmp	 $LN25@PlayThread
$LN24@PlayThread:

; 314  : 
; 315  :         // 
; 316  :         if(m_hWaveoutDev == NULL)

  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0008c	75 67		 jne	 SHORT $LN23@PlayThread

; 317  :         {
; 318  :             EnterCriticalSection(&m_cs);

  0008e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00091	83 c0 50	 add	 eax, 80			; 00000050H
  00094	8b f4		 mov	 esi, esp
  00096	50		 push	 eax
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 319  :             MMRESULT mmres = waveOutOpen(&m_hWaveoutDev, WAVE_MAPPER, &m_waveData.wfmtx, (DWORD_PTR)WaveOutProc, (DWORD_PTR)this, CALLBACK_FUNCTION);

  000a4	8b f4		 mov	 esi, esp
  000a6	68 00 00 03 00	 push	 196608			; 00030000H
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	50		 push	 eax
  000af	68 00 00 00 00	 push	 OFFSET ?WaveOutProc@WavePlayer@@KGHPAUHWAVEOUT__@@IKKK@Z ; WavePlayer::WaveOutProc
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	83 c1 24	 add	 ecx, 36			; 00000024H
  000ba	51		 push	 ecx
  000bb	6a ff		 push	 -1
  000bd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c0	83 c2 10	 add	 edx, 16			; 00000010H
  000c3	52		 push	 edx
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24
  000ca	3b f4		 cmp	 esi, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	89 45 e0	 mov	 DWORD PTR _mmres$10[ebp], eax

; 320  :             LeaveCriticalSection(&m_cs);

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	83 c0 50	 add	 eax, 80			; 00000050H
  000da	8b f4		 mov	 esi, esp
  000dc	50		 push	 eax
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000e3	3b f4		 cmp	 esi, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 321  :             if(mmres != MMSYSERR_NOERROR)

  000ea	83 7d e0 00	 cmp	 DWORD PTR _mmres$10[ebp], 0
  000ee	74 05		 je	 SHORT $LN23@PlayThread

; 322  :             {
; 323  :                 // failed, try again.
; 324  :                 continue;

  000f0	e9 35 ff ff ff	 jmp	 $LN26@PlayThread
$LN23@PlayThread:

; 325  :             }
; 326  :         }
; 327  :         
; 328  :         // 
; 329  :         EnterCriticalSection( &m_cs );

  000f5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	83 c0 50	 add	 eax, 80			; 00000050H
  000fb	8b f4		 mov	 esi, esp
  000fd	50		 push	 eax
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00104	3b f4		 cmp	 esi, esp
  00106	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 330  :         int free = m_wBlock.wfreeblock;

  0010b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00111	89 4d d4	 mov	 DWORD PTR _free$9[ebp], ecx

; 331  :         LeaveCriticalSection( &m_cs );

  00114	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00117	83 c0 50	 add	 eax, 80			; 00000050H
  0011a	8b f4		 mov	 esi, esp
  0011c	50		 push	 eax
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00123	3b f4		 cmp	 esi, esp
  00125	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 332  : 
; 333  :         // ...
; 334  :         if(free < BP_TURN)

  0012a	83 7d d4 01	 cmp	 DWORD PTR _free$9[ebp], 1
  0012e	7d 05		 jge	 SHORT $LN21@PlayThread

; 335  :         {
; 336  :             continue;

  00130	e9 f5 fe ff ff	 jmp	 $LN26@PlayThread
$LN21@PlayThread:

; 337  :         }
; 338  : 
; 339  :         /////////////////////////////////////////////////////////////////////////
; 340  :         /////////////////////////////////////////////////////////////////////////
; 341  :         ///                       <  >                              ///
; 342  :         /////////////////////////////////////////////////////////////////////////
; 343  :         /////////////////////////////////////////////////////////////////////////
; 344  : 
; 345  :         WAVEHDR     *current = NULL;

  00135	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _current$8[ebp], 0

; 346  : 
; 347  :         /// BP_TURN
; 348  :         for( unsigned int m = 0; m < BP_TURN; m++ )

  0013c	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _m$7[ebp], 0
  00143	eb 09		 jmp	 SHORT $LN20@PlayThread
$LN19@PlayThread:
  00145	8b 45 bc	 mov	 eax, DWORD PTR _m$7[ebp]
  00148	83 c0 01	 add	 eax, 1
  0014b	89 45 bc	 mov	 DWORD PTR _m$7[ebp], eax
$LN20@PlayThread:
  0014e	83 7d bc 01	 cmp	 DWORD PTR _m$7[ebp], 1
  00152	0f 83 69 02 00
	00		 jae	 $LN18@PlayThread

; 349  :         {   
; 350  :             /// 
; 351  :             current = &m_wBlock.pWaveHdr[m_wBlock.wcurrblock]; 

  00158	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0015b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0015e	c1 e1 05	 shl	 ecx, 5
  00161	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00164	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  00167	89 4d c8	 mov	 DWORD PTR _current$8[ebp], ecx

; 352  : 
; 353  :             // Unprepare
; 354  :             if( current->dwFlags & WHDR_PREPARED )

  0016a	8b 45 c8	 mov	 eax, DWORD PTR _current$8[ebp]
  0016d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00170	83 e1 02	 and	 ecx, 2
  00173	74 1c		 je	 SHORT $LN17@PlayThread

; 355  :             {
; 356  :                 waveOutUnprepareHeader( m_hWaveoutDev, current, sizeof(WAVEHDR) );

  00175	8b f4		 mov	 esi, esp
  00177	6a 20		 push	 32			; 00000020H
  00179	8b 45 c8	 mov	 eax, DWORD PTR _current$8[ebp]
  0017c	50		 push	 eax
  0017d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00183	52		 push	 edx
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutUnprepareHeader@12
  0018a	3b f4		 cmp	 esi, esp
  0018c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN17@PlayThread:

; 357  :             }
; 358  : 
; 359  :             /// 
; 360  :             EnterCriticalSection(&m_cs);

  00191	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00194	83 c0 50	 add	 eax, 80			; 00000050H
  00197	8b f4		 mov	 esi, esp
  00199	50		 push	 eax
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  001a0	3b f4		 cmp	 esi, esp
  001a2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 361  :             unsigned long left  = m_waveData.dwSize - m_wBlock.wpos;

  001a7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001aa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ad	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  001b0	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  001b3	89 55 b0	 mov	 DWORD PTR _left$6[ebp], edx

; 362  :             unsigned int bDecodeFinished = m_waveData.bDecodeFinished;

  001b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001b9	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  001bc	89 4d a4	 mov	 DWORD PTR _bDecodeFinished$5[ebp], ecx

; 363  :             LeaveCriticalSection(&m_cs);

  001bf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001c2	83 c0 50	 add	 eax, 80			; 00000050H
  001c5	8b f4		 mov	 esi, esp
  001c7	50		 push	 eax
  001c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  001ce	3b f4		 cmp	 esi, esp
  001d0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 364  :             unsigned long chunk = 0;

  001d5	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _chunk$4[ebp], 0

; 365  : 
; 366  :             if( left  >= BLOCK_SIZE )

  001dc	81 7d b0 a0 0f
	00 00		 cmp	 DWORD PTR _left$6[ebp], 4000 ; 00000fa0H
  001e3	72 0c		 jb	 SHORT $LN16@PlayThread

; 367  :             {
; 368  :                 chunk  = BLOCK_SIZE;

  001e5	c7 45 98 a0 0f
	00 00		 mov	 DWORD PTR _chunk$4[ebp], 4000 ; 00000fa0H
  001ec	e9 d2 00 00 00	 jmp	 $LN15@PlayThread
$LN16@PlayThread:

; 369  :             }
; 370  :             else if(!bDecodeFinished)

  001f1	83 7d a4 00	 cmp	 DWORD PTR _bDecodeFinished$5[ebp], 0
  001f5	75 0a		 jne	 SHORT $LN14@PlayThread

; 371  :             {
; 372  :                 // 
; 373  :                 break;

  001f7	e9 c5 01 00 00	 jmp	 $LN18@PlayThread
  001fc	e9 c2 00 00 00	 jmp	 $LN15@PlayThread
$LN14@PlayThread:

; 374  :             }
; 375  :             else if( left && left < BLOCK_SIZE)

  00201	83 7d b0 00	 cmp	 DWORD PTR _left$6[ebp], 0
  00205	74 14		 je	 SHORT $LN12@PlayThread
  00207	81 7d b0 a0 0f
	00 00		 cmp	 DWORD PTR _left$6[ebp], 4000 ; 00000fa0H
  0020e	73 0b		 jae	 SHORT $LN12@PlayThread

; 376  :             {
; 377  :                 chunk  = left;

  00210	8b 45 b0	 mov	 eax, DWORD PTR _left$6[ebp]
  00213	89 45 98	 mov	 DWORD PTR _chunk$4[ebp], eax

; 378  :             }
; 379  :             else

  00216	e9 a8 00 00 00	 jmp	 $LN15@PlayThread
$LN12@PlayThread:

; 380  :             {   
; 381  :                 //////////////////////////////////////////////////////////////////////
; 382  :                 ///                 < >                                    ///
; 383  :                 //////////////////////////////////////////////////////////////////////
; 384  : 
; 385  :                 /// 
; 386  :                 EnterCriticalSection( &m_cs );

  0021b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0021e	83 c0 50	 add	 eax, 80			; 00000050H
  00221	8b f4		 mov	 esi, esp
  00223	50		 push	 eax
  00224	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0022a	3b f4		 cmp	 esi, esp
  0022c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 387  :                 int free = m_wBlock.wfreeblock;

  00231	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00234	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00237	89 4d 8c	 mov	 DWORD PTR _free$3[ebp], ecx

; 388  :                 LeaveCriticalSection( &m_cs );

  0023a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	83 c0 50	 add	 eax, 80			; 00000050H
  00240	8b f4		 mov	 esi, esp
  00242	50		 push	 eax
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00249	3b f4		 cmp	 esi, esp
  0024b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 389  : 
; 390  :                 /// 
; 391  :                 if( free == BLOCK_COUNT )

  00250	83 7d 8c 14	 cmp	 DWORD PTR _free$3[ebp], 20 ; 00000014H
  00254	75 68		 jne	 SHORT $LN10@PlayThread

; 392  :                 {
; 393  :                     /// Unprepare
; 394  :                     for( int j = 0; j < m_wBlock.wfreeblock; j++) 

  00256	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _j$2[ebp], 0
  0025d	eb 09		 jmp	 SHORT $LN9@PlayThread
$LN8@PlayThread:
  0025f	8b 45 80	 mov	 eax, DWORD PTR _j$2[ebp]
  00262	83 c0 01	 add	 eax, 1
  00265	89 45 80	 mov	 DWORD PTR _j$2[ebp], eax
$LN9@PlayThread:
  00268	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0026b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0026e	39 4d 80	 cmp	 DWORD PTR _j$2[ebp], ecx
  00271	7d 3c		 jge	 SHORT $LN7@PlayThread

; 395  :                     {
; 396  :                         if( m_wBlock.pWaveHdr[j].dwFlags & WHDR_PREPARED )

  00273	8b 45 80	 mov	 eax, DWORD PTR _j$2[ebp]
  00276	c1 e0 05	 shl	 eax, 5
  00279	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0027c	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0027f	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  00283	83 e0 02	 and	 eax, 2
  00286	74 25		 je	 SHORT $LN6@PlayThread

; 397  :                         {
; 398  :                             waveOutUnprepareHeader(m_hWaveoutDev, &m_wBlock.pWaveHdr[j], sizeof(WAVEHDR));

  00288	8b f4		 mov	 esi, esp
  0028a	6a 20		 push	 32			; 00000020H
  0028c	8b 45 80	 mov	 eax, DWORD PTR _j$2[ebp]
  0028f	c1 e0 05	 shl	 eax, 5
  00292	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00295	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  00298	50		 push	 eax
  00299	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0029c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0029f	50		 push	 eax
  002a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutUnprepareHeader@12
  002a6	3b f4		 cmp	 esi, esp
  002a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@PlayThread:

; 399  :                         }
; 400  :                     }

  002ad	eb b0		 jmp	 SHORT $LN8@PlayThread
$LN7@PlayThread:

; 401  : 
; 402  :                     // 
; 403  :                     tmsg = TMSG_CLOSE;

  002af	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tmsg$[ebp], 0

; 404  :                     // 
; 405  :                     OnPlayFinished();

  002b6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b9	e8 00 00 00 00	 call	 ?OnPlayFinished@WavePlayer@@IAEXXZ ; WavePlayer::OnPlayFinished
$LN10@PlayThread:

; 406  :                 }
; 407  : 
; 408  :                 // break
; 409  :                 break;

  002be	e9 fe 00 00 00	 jmp	 $LN18@PlayThread
$LN15@PlayThread:

; 410  :             }
; 411  : 
; 412  :             /// prepare current wave data block header
; 413  :             EnterCriticalSection(&m_cs);

  002c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002c6	83 c0 50	 add	 eax, 80			; 00000050H
  002c9	8b f4		 mov	 esi, esp
  002cb	50		 push	 eax
  002cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  002d2	3b f4		 cmp	 esi, esp
  002d4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 414  :             memcpy( current->lpData, &m_waveData.pData[m_wBlock.wpos], chunk );

  002d9	8b 45 98	 mov	 eax, DWORD PTR _chunk$4[ebp]
  002dc	50		 push	 eax
  002dd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e0	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  002e3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002e6	03 50 14	 add	 edx, DWORD PTR [eax+20]
  002e9	52		 push	 edx
  002ea	8b 4d c8	 mov	 ecx, DWORD PTR _current$8[ebp]
  002ed	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ef	52		 push	 edx
  002f0	e8 00 00 00 00	 call	 _memcpy
  002f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 415  :             LeaveCriticalSection(&m_cs);

  002f8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002fb	83 c0 50	 add	 eax, 80			; 00000050H
  002fe	8b f4		 mov	 esi, esp
  00300	50		 push	 eax
  00301	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00307	3b f4		 cmp	 esi, esp
  00309	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 416  : 
; 417  :             current->dwBufferLength  = chunk;   // sizeof block

  0030e	8b 45 c8	 mov	 eax, DWORD PTR _current$8[ebp]
  00311	8b 4d 98	 mov	 ecx, DWORD PTR _chunk$4[ebp]
  00314	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 418  :             m_wBlock.wpos           += chunk;   // update position

  00317	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0031a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0031d	03 4d 98	 add	 ecx, DWORD PTR _chunk$4[ebp]
  00320	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00323	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 419  : 
; 420  :             /// prepare for playback
; 421  :             waveOutPrepareHeader( m_hWaveoutDev, current, sizeof(WAVEHDR) );

  00326	8b f4		 mov	 esi, esp
  00328	6a 20		 push	 32			; 00000020H
  0032a	8b 45 c8	 mov	 eax, DWORD PTR _current$8[ebp]
  0032d	50		 push	 eax
  0032e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00331	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00334	52		 push	 edx
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPrepareHeader@12
  0033b	3b f4		 cmp	 esi, esp
  0033d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 422  : 
; 423  :             /// push to the queue
; 424  :             waveOutWrite(m_hWaveoutDev, current, sizeof(WAVEHDR));

  00342	8b f4		 mov	 esi, esp
  00344	6a 20		 push	 32			; 00000020H
  00346	8b 45 c8	 mov	 eax, DWORD PTR _current$8[ebp]
  00349	50		 push	 eax
  0034a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0034d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00350	52		 push	 edx
  00351	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutWrite@12
  00357	3b f4		 cmp	 esi, esp
  00359	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 425  : 
; 426  :             /// 
; 427  :             EnterCriticalSection( &m_cs );

  0035e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00361	83 c0 50	 add	 eax, 80			; 00000050H
  00364	8b f4		 mov	 esi, esp
  00366	50		 push	 eax
  00367	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0036d	3b f4		 cmp	 esi, esp
  0036f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 428  :             m_wBlock.wfreeblock--;

  00374	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00377	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0037a	83 e9 01	 sub	 ecx, 1
  0037d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00380	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 429  :             LeaveCriticalSection( &m_cs );

  00383	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00386	83 c0 50	 add	 eax, 80			; 00000050H
  00389	8b f4		 mov	 esi, esp
  0038b	50		 push	 eax
  0038c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00392	3b f4		 cmp	 esi, esp
  00394	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 430  : 
; 431  :             /// 
; 432  :             m_wBlock.wcurrblock++;

  00399	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0039c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0039f	83 c1 01	 add	 ecx, 1
  003a2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003a5	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 433  :             m_wBlock.wcurrblock %= BLOCK_COUNT;

  003a8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003ab	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  003ae	99		 cdq
  003af	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  003b4	f7 f9		 idiv	 ecx
  003b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003b9	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 434  :         }

  003bc	e9 84 fd ff ff	 jmp	 $LN19@PlayThread
$LN18@PlayThread:

; 435  : 
; 436  :     }/// thread

  003c1	e9 64 fc ff ff	 jmp	 $LN26@PlayThread
$LN25@PlayThread:

; 437  : 
; 438  :     ///////////////////////////////////////////////////////////////////////////////
; 439  :     ///////////////////////////////////////////////////////////////////////////////
; 440  :     ///
; 441  :     ///            < force to close device which are still playing > 
; 442  :     ///////////////////////////////////////////////////////////////////////////////
; 443  :     ///////////////////////////////////////////////////////////////////////////////
; 444  :     if(m_hWaveoutDev)

  003c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003c9	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  003cd	0f 84 9c 00 00
	00		 je	 $LN5@PlayThread

; 445  :     {
; 446  :         waveOutReset( m_hWaveoutDev );

  003d3	8b f4		 mov	 esi, esp
  003d5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003d8	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003db	51		 push	 ecx
  003dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutReset@4
  003e2	3b f4		 cmp	 esi, esp
  003e4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 447  : 
; 448  :         /// unprepare any blocks that are still prepared
; 449  :         for( int j = 0; j < BLOCK_COUNT; j++) 

  003e9	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$1[ebp], 0
  003f3	eb 0f		 jmp	 SHORT $LN4@PlayThread
$LN3@PlayThread:
  003f5	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  003fb	83 c0 01	 add	 eax, 1
  003fe	89 85 74 ff ff
	ff		 mov	 DWORD PTR _j$1[ebp], eax
$LN4@PlayThread:
  00404	83 bd 74 ff ff
	ff 14		 cmp	 DWORD PTR _j$1[ebp], 20	; 00000014H
  0040b	7d 42		 jge	 SHORT $LN2@PlayThread

; 450  :         {
; 451  :             if( m_wBlock.pWaveHdr[j].dwFlags & WHDR_PREPARED )

  0040d	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  00413	c1 e0 05	 shl	 eax, 5
  00416	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00419	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0041c	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  00420	83 e0 02	 and	 eax, 2
  00423	74 28		 je	 SHORT $LN1@PlayThread

; 452  :             {
; 453  :                 waveOutUnprepareHeader(m_hWaveoutDev, &m_wBlock.pWaveHdr[j], sizeof(WAVEHDR));

  00425	8b f4		 mov	 esi, esp
  00427	6a 20		 push	 32			; 00000020H
  00429	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  0042f	c1 e0 05	 shl	 eax, 5
  00432	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00435	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  00438	50		 push	 eax
  00439	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0043c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0043f	50		 push	 eax
  00440	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutUnprepareHeader@12
  00446	3b f4		 cmp	 esi, esp
  00448	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@PlayThread:

; 454  :             }
; 455  :         }

  0044d	eb a6		 jmp	 SHORT $LN3@PlayThread
$LN2@PlayThread:

; 456  : 
; 457  :         waveOutClose(m_hWaveoutDev);

  0044f	8b f4		 mov	 esi, esp
  00451	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00454	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00457	51		 push	 ecx
  00458	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutClose@4
  0045e	3b f4		 cmp	 esi, esp
  00460	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 458  :         m_hWaveoutDev = NULL;

  00465	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00468	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN5@PlayThread:

; 459  :     }
; 460  : 
; 461  :     return THREAD_EXIT;

  0046f	b8 da ce be 0a	 mov	 eax, 180276954		; 0abecedaH

; 462  : }

  00474	5f		 pop	 edi
  00475	5e		 pop	 esi
  00476	5b		 pop	 ebx
  00477	81 c4 50 01 00
	00		 add	 esp, 336		; 00000150H
  0047d	3b ec		 cmp	 ebp, esp
  0047f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00484	8b e5		 mov	 esp, ebp
  00486	5d		 pop	 ebp
  00487	c3		 ret	 0
?PlayThreadProcImpl@WavePlayer@@IAEIXZ ENDP		; WavePlayer::PlayThreadProcImpl
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?PlayThread@WavePlayer@@KGIPAX@Z
_TEXT	SEGMENT
_pPlayer$ = -8						; size = 4
_lp$ = 8						; size = 4
?PlayThread@WavePlayer@@KGIPAX@Z PROC			; WavePlayer::PlayThread, COMDAT

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 292  :     WavePlayer *pPlayer = ( WavePlayer *)lp;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _lp$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _pPlayer$[ebp], eax

; 293  : 
; 294  :     return pPlayer->PlayThreadProcImpl();

  00024	8b 4d f8	 mov	 ecx, DWORD PTR _pPlayer$[ebp]
  00027	e8 00 00 00 00	 call	 ?PlayThreadProcImpl@WavePlayer@@IAEIXZ ; WavePlayer::PlayThreadProcImpl

; 295  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?PlayThread@WavePlayer@@KGIPAX@Z ENDP			; WavePlayer::PlayThread
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?WaveOutProcImpl@WavePlayer@@IAEHPAUHWAVEOUT__@@IKK@Z
_TEXT	SEGMENT
tv156 = -276						; size = 4
tv132 = -276						; size = 4
_percent$1 = -76					; size = 4
_total$2 = -64						; size = 4
_interval$3 = -52					; size = 4
_wfmtx$4 = -40						; size = 18
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_hwo$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_dwParam1$ = 16						; size = 4
_dwParam2$ = 20						; size = 4
?WaveOutProcImpl@WavePlayer@@IAEHPAUHWAVEOUT__@@IKK@Z PROC ; WavePlayer::WaveOutProcImpl, COMDAT
; _this$ = ecx

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00013	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 270  :     // 
; 271  :     if(uMsg == WOM_DONE)

  0002d	81 7d 0c bd 03
	00 00		 cmp	 DWORD PTR _uMsg$[ebp], 957 ; 000003bdH
  00034	0f 85 5f 01 00
	00		 jne	 $LN2@WaveOutPro

; 272  :     {
; 273  :         // 
; 274  :         EnterCriticalSection(&m_cs);

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 c0 50	 add	 eax, 80			; 00000050H
  00040	8b f4		 mov	 esi, esp
  00042	50		 push	 eax
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00049	3b f4		 cmp	 esi, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 275  :         ++m_wBlock.wfreeblock;

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00056	83 c1 01	 add	 ecx, 1
  00059	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 276  : 		if (m_soundCB)

  0005f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00062	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  00066	0f 84 17 01 00
	00		 je	 $LN1@WaveOutPro

; 277  : 		{
; 278  : 			WAVEFORMATEX wfmtx = m_pDecoder->GetWaveFromatX();

  0006c	8b f4		 mov	 esi, esp
  0006e	8d 45 d8	 lea	 eax, DWORD PTR _wfmtx$4[ebp]
  00071	50		 push	 eax
  00072	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00078	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 12		 mov	 edx, DWORD PTR [edx]
  0007d	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00080	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00083	ff d0		 call	 eax
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 279  : 			int interval = (BLOCK_SIZE * 1000) / wfmtx.nAvgBytesPerSec;

  0008c	b8 00 09 3d 00	 mov	 eax, 4000000		; 003d0900H
  00091	33 d2		 xor	 edx, edx
  00093	f7 75 e0	 div	 DWORD PTR _wfmtx$4[ebp+8]
  00096	89 45 cc	 mov	 DWORD PTR _interval$3[ebp], eax

; 280  : 			int total = ceil(float(m_pDecoder->GetTimeLength()) / interval);

  00099	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0009f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000a2	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a4	8b f4		 mov	 esi, esp
  000a6	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  000a9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ac	ff d2		 call	 edx
  000ae	3b f4		 cmp	 esi, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b5	8b c8		 mov	 ecx, eax
  000b7	e8 00 00 00 00	 call	 __ultod3
  000bc	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  000c0	f3 0f 2a 4d cc	 cvtsi2ss xmm1, DWORD PTR _interval$3[ebp]
  000c5	f3 0f 5e c1	 divss	 xmm0, xmm1
  000c9	51		 push	 ecx
  000ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cf	e8 00 00 00 00	 call	 ?ceil@@YAMM@Z		; ceil
  000d4	83 c4 04	 add	 esp, 4
  000d7	e8 00 00 00 00	 call	 __ftol2_sse
  000dc	89 45 c0	 mov	 DWORD PTR _total$2[ebp], eax

; 281  : 			int percent = ++m_notification * 100 / total;

  000df	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  000e5	83 c1 01	 add	 ecx, 1
  000e8	89 8d ec fe ff
	ff		 mov	 DWORD PTR tv132[ebp], ecx
  000ee	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000f1	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv132[ebp]
  000f7	89 42 70	 mov	 DWORD PTR [edx+112], eax
  000fa	6b 85 ec fe ff
	ff 64		 imul	 eax, DWORD PTR tv132[ebp], 100
  00101	33 d2		 xor	 edx, edx
  00103	f7 75 c0	 div	 DWORD PTR _total$2[ebp]
  00106	89 45 b4	 mov	 DWORD PTR _percent$1[ebp], eax

; 282  : 			m_soundCB->onPlayingNotification(percent > 100 ? 100 : percent, (float)m_pDecoder->GetTimeLength() / 1000, m_cbData);

  00109	83 7d b4 64	 cmp	 DWORD PTR _percent$1[ebp], 100 ; 00000064H
  0010d	7e 0c		 jle	 SHORT $LN5@WaveOutPro
  0010f	c7 85 ec fe ff
	ff 64 00 00 00	 mov	 DWORD PTR tv156[ebp], 100 ; 00000064H
  00119	eb 09		 jmp	 SHORT $LN6@WaveOutPro
$LN5@WaveOutPro:
  0011b	8b 45 b4	 mov	 eax, DWORD PTR _percent$1[ebp]
  0011e	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv156[ebp], eax
$LN6@WaveOutPro:
  00124	8b f4		 mov	 esi, esp
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  0012c	52		 push	 edx
  0012d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00130	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00133	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00136	8b 01		 mov	 eax, DWORD PTR [ecx]
  00138	8b fc		 mov	 edi, esp
  0013a	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  0013d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00140	ff d2		 call	 edx
  00142	3b fc		 cmp	 edi, esp
  00144	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00149	8b c8		 mov	 ecx, eax
  0014b	e8 00 00 00 00	 call	 __ultod3
  00150	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00154	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  0015c	51		 push	 ecx
  0015d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00162	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv156[ebp]
  00168	50		 push	 eax
  00169	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  0016f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00172	8b 12		 mov	 edx, DWORD PTR [edx]
  00174	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00177	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0017a	ff d0		 call	 eax
  0017c	3b f4		 cmp	 esi, esp
  0017e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@WaveOutPro:

; 283  : 		}
; 284  : 		LeaveCriticalSection(&m_cs);

  00183	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00186	83 c0 50	 add	 eax, 80			; 00000050H
  00189	8b f4		 mov	 esi, esp
  0018b	50		 push	 eax
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00192	3b f4		 cmp	 esi, esp
  00194	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@WaveOutPro:

; 285  :     }
; 286  : 
; 287  :     return TRUE;

  00199	b8 01 00 00 00	 mov	 eax, 1

; 288  : }

  0019e	52		 push	 edx
  0019f	8b cd		 mov	 ecx, ebp
  001a1	50		 push	 eax
  001a2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@WaveOutPro
  001a8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001ad	58		 pop	 eax
  001ae	5a		 pop	 edx
  001af	5f		 pop	 edi
  001b0	5e		 pop	 esi
  001b1	5b		 pop	 ebx
  001b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b5	33 cd		 xor	 ecx, ebp
  001b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bc	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  001c2	3b ec		 cmp	 ebp, esp
  001c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 10 00	 ret	 16			; 00000010H
  001cf	90		 npad	 1
$LN9@WaveOutPro:
  001d0	01 00 00 00	 DD	 1
  001d4	00 00 00 00	 DD	 $LN8@WaveOutPro
$LN8@WaveOutPro:
  001d8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  001dc	12 00 00 00	 DD	 18			; 00000012H
  001e0	00 00 00 00	 DD	 $LN7@WaveOutPro
$LN7@WaveOutPro:
  001e4	77		 DB	 119			; 00000077H
  001e5	66		 DB	 102			; 00000066H
  001e6	6d		 DB	 109			; 0000006dH
  001e7	74		 DB	 116			; 00000074H
  001e8	78		 DB	 120			; 00000078H
  001e9	00		 DB	 0
?WaveOutProcImpl@WavePlayer@@IAEHPAUHWAVEOUT__@@IKK@Z ENDP ; WavePlayer::WaveOutProcImpl
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?WaveOutProc@WavePlayer@@KGHPAUHWAVEOUT__@@IKKK@Z
_TEXT	SEGMENT
_pPlayer$ = -8						; size = 4
_hwo$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_dwInstance$ = 16					; size = 4
_dwParam1$ = 20						; size = 4
_dwParam2$ = 24						; size = 4
?WaveOutProc@WavePlayer@@KGHPAUHWAVEOUT__@@IKKK@Z PROC	; WavePlayer::WaveOutProc, COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 263  :     WavePlayer* pPlayer = (WavePlayer*)dwInstance;

  0001e	8b 45 10	 mov	 eax, DWORD PTR _dwInstance$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _pPlayer$[ebp], eax

; 264  : 
; 265  :     return pPlayer->WaveOutProcImpl(hwo, uMsg, dwParam1, dwParam2);

  00024	8b 45 18	 mov	 eax, DWORD PTR _dwParam2$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 14	 mov	 ecx, DWORD PTR _dwParam1$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 0c	 mov	 edx, DWORD PTR _uMsg$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR _hwo$[ebp]
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _pPlayer$[ebp]
  00037	e8 00 00 00 00	 call	 ?WaveOutProcImpl@WavePlayer@@IAEHPAUHWAVEOUT__@@IKK@Z ; WavePlayer::WaveOutProcImpl

; 266  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 14 00	 ret	 20			; 00000014H
?WaveOutProc@WavePlayer@@KGHPAUHWAVEOUT__@@IKKK@Z ENDP	; WavePlayer::WaveOutProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?SetCallback@WavePlayer@@QAEXPAVISoundCallBack@@J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_psoundCB$ = 8						; size = 4
_cbData$ = 12						; size = 4
?SetCallback@WavePlayer@@QAEXPAVISoundCallBack@@J@Z PROC ; WavePlayer::SetCallback, COMDAT
; _this$ = ecx

; 542  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 543  : 	m_soundCB = psoundCB;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _psoundCB$[ebp]
  00029	89 48 68	 mov	 DWORD PTR [eax+104], ecx

; 544  : 	m_cbData = cbData;

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _cbData$[ebp]
  00032	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 545  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
?SetCallback@WavePlayer@@QAEXPAVISoundCallBack@@J@Z ENDP ; WavePlayer::SetCallback
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?SetVolume@WavePlayer@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_dwVolume$ = 8						; size = 4
?SetVolume@WavePlayer@@QAEXK@Z PROC			; WavePlayer::SetVolume, COMDAT
; _this$ = ecx

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 237  :     waveOutSetVolume(m_hWaveoutDev, dwVolume);

  00023	8b f4		 mov	 esi, esp
  00025	8b 45 08	 mov	 eax, DWORD PTR _dwVolume$[ebp]
  00028	50		 push	 eax
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0002f	52		 push	 edx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 238  : }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?SetVolume@WavePlayer@@QAEXK@Z ENDP			; WavePlayer::SetVolume
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?GetAudioLength@WavePlayer@@QAEKPB_W@Z
_TEXT	SEGMENT
tv75 = -256						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_dwTimeLength$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_lpszFile$ = 8						; size = 4
?GetAudioLength@WavePlayer@@QAEKPB_W@Z PROC		; WavePlayer::GetAudioLength, COMDAT
; _this$ = ecx

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetAudioLength@WavePlayer@@QAEKPB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00021	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 242  :     // 
; 243  :     if(m_pDecoder == NULL)

  00042	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00045	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00049	75 62		 jne	 SHORT $LN3@GetAudioLe

; 244  :     {
; 245  :         m_pDecoder = new AMRFileDecoder(lpszFile);

  0004b	6a 40		 push	 64			; 00000040H
  0004d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00052	83 c4 04	 add	 esp, 4
  00055	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00062	83 bd 14 ff ff
	ff 00		 cmp	 DWORD PTR $T3[ebp], 0
  00069	74 17		 je	 SHORT $LN6@GetAudioLe
  0006b	8b 45 08	 mov	 eax, DWORD PTR _lpszFile$[ebp]
  0006e	50		 push	 eax
  0006f	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00075	e8 00 00 00 00	 call	 ??0AMRFileDecoder@@QAE@PB_W@Z ; AMRFileDecoder::AMRFileDecoder
  0007a	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  00080	eb 0a		 jmp	 SHORT $LN7@GetAudioLe
$LN6@GetAudioLe:
  00082	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv75[ebp], 0
$LN7@GetAudioLe:
  0008c	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  00092	89 8d 08 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00098	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000a2	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  000a8	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 246  :     }
; 247  :     else

  000ab	eb 20		 jmp	 SHORT $LN2@GetAudioLe
$LN3@GetAudioLe:

; 248  :     {
; 249  :         m_pDecoder->SetFilePathName(lpszFile);

  000ad	8b f4		 mov	 esi, esp
  000af	8b 45 08	 mov	 eax, DWORD PTR _lpszFile$[ebp]
  000b2	50		 push	 eax
  000b3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  000b9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	8b 12		 mov	 edx, DWORD PTR [edx]
  000be	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000c1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c4	ff d0		 call	 eax
  000c6	3b f4		 cmp	 esi, esp
  000c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@GetAudioLe:

; 250  :     }
; 251  : 
; 252  :     DWORD dwTimeLength = 0;

  000cd	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _dwTimeLength$[ebp], 0

; 253  :     if(m_pDecoder)

  000d4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  000db	74 1f		 je	 SHORT $LN1@GetAudioLe

; 254  :     {
; 255  :         dwTimeLength = (DWORD)m_pDecoder->GetTimeLength();

  000dd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000e3	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000e6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e8	8b f4		 mov	 esi, esp
  000ea	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  000ed	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000f0	ff d2		 call	 edx
  000f2	3b f4		 cmp	 esi, esp
  000f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f9	89 45 e0	 mov	 DWORD PTR _dwTimeLength$[ebp], eax
$LN1@GetAudioLe:

; 256  :     }
; 257  :    
; 258  :     return dwTimeLength;

  000fc	8b 45 e0	 mov	 eax, DWORD PTR _dwTimeLength$[ebp]

; 259  : }

  000ff	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00102	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00109	59		 pop	 ecx
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  00113	3b ec		 cmp	 ebp, esp
  00115	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetAudioLength@WavePlayer@@QAEKPB_W@Z$0:
  00000	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$?GetAudioLength@WavePlayer@@QAEKPB_W@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 8a fc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-260]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetAudioLength@WavePlayer@@QAEKPB_W@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetAudioLength@WavePlayer@@QAEKPB_W@Z ENDP		; WavePlayer::GetAudioLength
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?Stop@WavePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Stop@WavePlayer@@QAEXXZ PROC				; WavePlayer::Stop, COMDAT
; _this$ = ecx

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 228  :     m_ePlayStat = Play_Stop;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 229  : 
; 230  :     UnInit();

  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?UnInit@WavePlayer@@IAEXXZ ; WavePlayer::UnInit

; 231  : 
; 232  :     OnPlayFinished();

  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?OnPlayFinished@WavePlayer@@IAEXXZ ; WavePlayer::OnPlayFinished

; 233  : }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?Stop@WavePlayer@@QAEXXZ ENDP				; WavePlayer::Stop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?Resume@WavePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Resume@WavePlayer@@QAEXXZ PROC				; WavePlayer::Resume, COMDAT
; _this$ = ecx

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 223  :     if(m_hWaveoutDev)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0002a	74 16		 je	 SHORT $LN2@Resume

; 224  :         waveOutRestart(m_hWaveoutDev);

  0002c	8b f4		 mov	 esi, esp
  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutRestart@4
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Resume:

; 225  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?Resume@WavePlayer@@QAEXXZ ENDP				; WavePlayer::Resume
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?Pause@WavePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Pause@WavePlayer@@QAEXXZ PROC				; WavePlayer::Pause, COMDAT
; _this$ = ecx

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 217  :     if(m_hWaveoutDev)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0002a	74 16		 je	 SHORT $LN2@Pause

; 218  :         waveOutPause(m_hWaveoutDev);

  0002c	8b f4		 mov	 esi, esp
  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPause@4
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Pause:

; 219  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?Pause@WavePlayer@@QAEXXZ ENDP				; WavePlayer::Pause
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?Play@WavePlayer@@QAEXPB_WPAK@Z
_TEXT	SEGMENT
tv78 = -288						; size = 4
$T2 = -280						; size = 18
$T3 = -252						; size = 4
$T4 = -240						; size = 4
_dwWaveMaxSize$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpszFile$ = 8						; size = 4
_pLength$ = 12						; size = 4
?Play@WavePlayer@@QAEXPB_WPAK@Z PROC			; WavePlayer::Play, COMDAT
; _this$ = ecx

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Play@WavePlayer@@QAEXPB_WPAK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00021	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 159  :     // 
; 160  :     if(m_ePlayStat != Play_Stop)

  00045	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0004c	74 08		 je	 SHORT $LN6@Play

; 161  :     {
; 162  :         Stop();

  0004e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?Stop@WavePlayer@@QAEXXZ ; WavePlayer::Stop
$LN6@Play:

; 163  :     }
; 164  : 
; 165  :     // 
; 166  :     if(m_pDecoder == NULL)

  00056	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  0005d	75 62		 jne	 SHORT $LN5@Play

; 167  :     {
; 168  :         m_pDecoder = new AMRFileDecoder(lpszFile);

  0005f	6a 40		 push	 64			; 00000040H
  00061	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00066	83 c4 04	 add	 esp, 4
  00069	89 85 10 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  0006f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00076	83 bd 10 ff ff
	ff 00		 cmp	 DWORD PTR $T4[ebp], 0
  0007d	74 17		 je	 SHORT $LN9@Play
  0007f	8b 45 08	 mov	 eax, DWORD PTR _lpszFile$[ebp]
  00082	50		 push	 eax
  00083	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  00089	e8 00 00 00 00	 call	 ??0AMRFileDecoder@@QAE@PB_W@Z ; AMRFileDecoder::AMRFileDecoder
  0008e	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  00094	eb 0a		 jmp	 SHORT $LN10@Play
$LN9@Play:
  00096	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
$LN10@Play:
  000a0	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  000a6	89 8d 04 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  000ac	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b3	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000b6	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  000bc	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 169  :     }
; 170  :     else

  000bf	eb 20		 jmp	 SHORT $LN4@Play
$LN5@Play:

; 171  :     {
; 172  :         m_pDecoder->SetFilePathName(lpszFile);

  000c1	8b f4		 mov	 esi, esp
  000c3	8b 45 08	 mov	 eax, DWORD PTR _lpszFile$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  000cd	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	8b 12		 mov	 edx, DWORD PTR [edx]
  000d2	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000d5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d8	ff d0		 call	 eax
  000da	3b f4		 cmp	 esi, esp
  000dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@Play:

; 173  :     }
; 174  : 
; 175  :     // 
; 176  :     if(pLength)

  000e1	83 7d 0c 00	 cmp	 DWORD PTR _pLength$[ebp], 0
  000e5	74 21		 je	 SHORT $LN3@Play

; 177  :     {
; 178  :         *pLength = (DWORD)m_pDecoder->GetTimeLength();

  000e7	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000ea	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000ed	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000f0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f2	8b f4		 mov	 esi, esp
  000f4	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  000f7	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000fa	ff d2		 call	 edx
  000fc	3b f4		 cmp	 esi, esp
  000fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00103	8b 4d 0c	 mov	 ecx, DWORD PTR _pLength$[ebp]
  00106	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@Play:

; 179  :     }
; 180  : 	m_notification = 0;

  00108	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0010b	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 181  : 
; 182  :     // 
; 183  :     DWORD dwWaveMaxSize = m_pDecoder->GetDecodedMaxSize();

  00112	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00115	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00118	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0011b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0011d	8b f4		 mov	 esi, esp
  0011f	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  00122	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00125	ff d2		 call	 edx
  00127	3b f4		 cmp	 esi, esp
  00129	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012e	89 45 dc	 mov	 DWORD PTR _dwWaveMaxSize$[ebp], eax

; 184  :     EnterCriticalSection(&m_cs);

  00131	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00134	83 c0 50	 add	 eax, 80			; 00000050H
  00137	8b f4		 mov	 esi, esp
  00139	50		 push	 eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00140	3b f4		 cmp	 esi, esp
  00142	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 185  :     m_waveData.wfmtx = m_pDecoder->GetWaveFromatX();

  00147	8b f4		 mov	 esi, esp
  00149	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0014f	50		 push	 eax
  00150	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00156	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00159	8b 12		 mov	 edx, DWORD PTR [edx]
  0015b	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0015e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00161	ff d0		 call	 eax
  00163	3b f4		 cmp	 esi, esp
  00165	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016d	83 c1 24	 add	 ecx, 36			; 00000024H
  00170	8b 10		 mov	 edx, DWORD PTR [eax]
  00172	89 11		 mov	 DWORD PTR [ecx], edx
  00174	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00177	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0017a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017d	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00180	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00183	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00186	66 8b 40 10	 mov	 ax, WORD PTR [eax+16]
  0018a	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 186  :     m_waveData.pData = (LPSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwWaveMaxSize);

  0018e	8b f4		 mov	 esi, esp
  00190	8b 45 dc	 mov	 eax, DWORD PTR _dwWaveMaxSize$[ebp]
  00193	50		 push	 eax
  00194	6a 08		 push	 8
  00196	8b fc		 mov	 edi, esp
  00198	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0019e	3b fc		 cmp	 edi, esp
  001a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a5	50		 push	 eax
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12
  001ac	3b f4		 cmp	 esi, esp
  001ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b6	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 187  :     LeaveCriticalSection(&m_cs);

  001b9	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001bc	83 c0 50	 add	 eax, 80			; 00000050H
  001bf	8b f4		 mov	 esi, esp
  001c1	50		 push	 eax
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  001c8	3b f4		 cmp	 esi, esp
  001ca	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 188  : 
; 189  :     // 
; 190  : 
; 191  :     // 
; 192  :     if(m_hThreadDecode == NULL)

  001cf	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001d2	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  001d6	0f 85 84 00 00
	00		 jne	 $LN2@Play

; 193  :     {
; 194  :         m_msgDecodeThread = TMSG_ALIVE;

  001dc	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001df	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [eax+72], 1

; 195  :         m_hThreadDecode = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)DecodeThread, (LPVOID)this, CREATE_SUSPENDED, NULL);

  001e6	8b f4		 mov	 esi, esp
  001e8	6a 00		 push	 0
  001ea	6a 04		 push	 4
  001ec	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001ef	50		 push	 eax
  001f0	68 00 00 00 00	 push	 OFFSET ?DecodeThread@WavePlayer@@KGIPAX@Z ; WavePlayer::DecodeThread
  001f5	6a 00		 push	 0
  001f7	6a 00		 push	 0
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  001ff	3b f4		 cmp	 esi, esp
  00201	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00206	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 196  :         ATLASSERT(m_hThreadDecode);

  0020c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0020f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00213	75 35		 jne	 SHORT $LN11@Play
  00215	8b f4		 mov	 esi, esp
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@FHBIINOD@?$AAm?$AA_?$AAh?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$AA@
  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00221	6a 00		 push	 0
  00223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?1??Play@WavePlayer@@QAEXPB_WPAK@Z@4JA
  00229	83 c1 26	 add	 ecx, 38			; 00000026H
  0022c	51		 push	 ecx
  0022d	68 00 00 00 00	 push	 OFFSET ??_C@_1JE@KOPMJDFJ@?$AAe?$AA?3?$AA?2?$AAm?$AAy?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAc?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?2?$AAp?$AAc?$AA2?$AA?4?$AA0?$AAt?$AAr?$AAu?$AAn?$AAk?$AA?2?$AAp?$AAc?$AA2?$AA?4@
  00232	6a 02		 push	 2
  00234	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0023a	83 c4 18	 add	 esp, 24			; 00000018H
  0023d	3b f4		 cmp	 esi, esp
  0023f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00244	83 f8 01	 cmp	 eax, 1
  00247	75 01		 jne	 SHORT $LN11@Play
  00249	cc		 int	 3
$LN11@Play:

; 197  :         ResumeThread(m_hThreadDecode);

  0024a	8b f4		 mov	 esi, esp
  0024c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0024f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00252	51		 push	 ecx
  00253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResumeThread@4
  00259	3b f4		 cmp	 esi, esp
  0025b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Play:

; 198  :     }
; 199  : 
; 200  :     // 
; 201  :     WaitForSingleObject(m_hEventDecode, INFINITE);

  00260	8b f4		 mov	 esi, esp
  00262	6a ff		 push	 -1
  00264	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00267	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0026a	51		 push	 ecx
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  00271	3b f4		 cmp	 esi, esp
  00273	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 202  : 
; 203  :     // 
; 204  :     if(m_hThreadPlay == NULL)

  00278	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0027b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0027e	0f 85 81 00 00
	00		 jne	 $LN1@Play

; 205  :     {
; 206  :         m_msgPlayThread = TMSG_ALIVE;

  00284	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00287	c7 40 44 01 00
	00 00		 mov	 DWORD PTR [eax+68], 1

; 207  :         m_hThreadPlay = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)PlayThread, (LPVOID)this, CREATE_SUSPENDED, NULL );

  0028e	8b f4		 mov	 esi, esp
  00290	6a 00		 push	 0
  00292	6a 04		 push	 4
  00294	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00297	50		 push	 eax
  00298	68 00 00 00 00	 push	 OFFSET ?PlayThread@WavePlayer@@KGIPAX@Z ; WavePlayer::PlayThread
  0029d	6a 00		 push	 0
  0029f	6a 00		 push	 0
  002a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  002a7	3b f4		 cmp	 esi, esp
  002a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ae	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	89 01		 mov	 DWORD PTR [ecx], eax

; 208  :         ATLASSERT(m_hThreadPlay);

  002b3	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  002b6	83 38 00	 cmp	 DWORD PTR [eax], 0
  002b9	75 35		 jne	 SHORT $LN12@Play
  002bb	8b f4		 mov	 esi, esp
  002bd	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@BEMNJFMJ@?$AAm?$AA_?$AAh?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AAP?$AAl?$AAa?$AAy?$AA?$AA@
  002c2	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  002c7	6a 00		 push	 0
  002c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?1??Play@WavePlayer@@QAEXPB_WPAK@Z@4JA
  002cf	83 c1 32	 add	 ecx, 50			; 00000032H
  002d2	51		 push	 ecx
  002d3	68 00 00 00 00	 push	 OFFSET ??_C@_1JE@KOPMJDFJ@?$AAe?$AA?3?$AA?2?$AAm?$AAy?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAc?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?2?$AAp?$AAc?$AA2?$AA?4?$AA0?$AAt?$AAr?$AAu?$AAn?$AAk?$AA?2?$AAp?$AAc?$AA2?$AA?4@
  002d8	6a 02		 push	 2
  002da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  002e0	83 c4 18	 add	 esp, 24			; 00000018H
  002e3	3b f4		 cmp	 esi, esp
  002e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ea	83 f8 01	 cmp	 eax, 1
  002ed	75 01		 jne	 SHORT $LN12@Play
  002ef	cc		 int	 3
$LN12@Play:

; 209  :         ResumeThread(m_hThreadPlay);

  002f0	8b f4		 mov	 esi, esp
  002f2	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  002f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f7	51		 push	 ecx
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResumeThread@4
  002fe	3b f4		 cmp	 esi, esp
  00300	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Play:

; 210  :     }
; 211  : 
; 212  :     m_ePlayStat = Play_Playing;

  00305	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00308	c7 40 08 02 00
	00 00		 mov	 DWORD PTR [eax+8], 2

; 213  : }

  0030f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00312	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00319	59		 pop	 ecx
  0031a	5f		 pop	 edi
  0031b	5e		 pop	 esi
  0031c	5b		 pop	 ebx
  0031d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00320	33 cd		 xor	 ecx, ebp
  00322	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00327	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  0032d	3b ec		 cmp	 ebp, esp
  0032f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00334	8b e5		 mov	 esp, ebp
  00336	5d		 pop	 ebp
  00337	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Play@WavePlayer@@QAEXPB_WPAK@Z$0:
  00000	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$?Play@WavePlayer@@QAEXPB_WPAK@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 8a dc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-292]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Play@WavePlayer@@QAEXPB_WPAK@Z
  00031	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Play@WavePlayer@@QAEXPB_WPAK@Z ENDP			; WavePlayer::Play
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ??1WavePlayer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1WavePlayer@@QAE@XZ PROC				; WavePlayer::~WavePlayer, COMDAT
; _this$ = ecx

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 47   :     UnInit();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?UnInit@WavePlayer@@IAEXXZ ; WavePlayer::UnInit

; 48   : 
; 49   :     // 
; 50   :     freeBlocks( m_wBlock.pWaveHdr );

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00031	51		 push	 ecx
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?freeBlocks@WavePlayer@@IAEXPAUwavehdr_tag@@@Z ; WavePlayer::freeBlocks

; 51   :     memset(&m_wBlock, 0, sizeof(WaveBlock));

  0003a	6a 10		 push	 16			; 00000010H
  0003c	6a 00		 push	 0
  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c0 14	 add	 eax, 20			; 00000014H
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memset
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 52   : 
; 53   :     if(m_hEventDecode)

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00054	74 20		 je	 SHORT $LN1@WavePlayer

; 54   :     {
; 55   :         CloseHandle(m_hEventDecode);

  00056	8b f4		 mov	 esi, esp
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0005e	51		 push	 ecx
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 56   :         m_hEventDecode = NULL;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$LN1@WavePlayer:

; 57   :     }
; 58   : 
; 59   :     // 
; 60   :     DeleteCriticalSection( &m_cs );

  00076	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00079	83 c0 50	 add	 eax, 80			; 00000050H
  0007c	8b f4		 mov	 esi, esp
  0007e	50		 push	 eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 61   : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
??1WavePlayer@@QAE@XZ ENDP				; WavePlayer::~WavePlayer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ??0WavePlayer@@QAE@XZ
_TEXT	SEGMENT
tv148 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0WavePlayer@@QAE@XZ PROC				; WavePlayer::WavePlayer, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0WavePlayer@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00021	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0005f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00069	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00073	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00076	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0
  0007d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00080	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0
  00087	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0
  00091	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00094	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0
  0009b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 27   :     memset(&m_waveData, 0, sizeof(WaveData));

  000a5	6a 20		 push	 32			; 00000020H
  000a7	6a 00		 push	 0
  000a9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	83 c0 24	 add	 eax, 36			; 00000024H
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _memset
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28   : 
; 29   :     // 
; 30   :     m_wBlock.pWaveHdr   = allocBlocks( BLOCK_SIZE, BLOCK_COUNT );

  000b8	6a 14		 push	 20			; 00000014H
  000ba	68 a0 0f 00 00	 push	 4000			; 00000fa0H
  000bf	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	e8 00 00 00 00	 call	 ?allocBlocks@WavePlayer@@IAEPAUwavehdr_tag@@HH@Z ; WavePlayer::allocBlocks
  000c7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 31   :     m_wBlock.wfreeblock = BLOCK_COUNT;

  000cd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	c7 40 1c 14 00
	00 00		 mov	 DWORD PTR [eax+28], 20	; 00000014H

; 32   :     m_wBlock.wcurrblock = 0;

  000d7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000da	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 33   :     m_wBlock.wpos       = 0;

  000e1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 34   : 
; 35   :     m_hEventDecode = CreateEvent(NULL, FALSE, FALSE, NULL);

  000eb	8b f4		 mov	 esi, esp
  000ed	6a 00		 push	 0
  000ef	6a 00		 push	 0
  000f1	6a 00		 push	 0
  000f3	6a 00		 push	 0
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventW@16
  000fb	3b f4		 cmp	 esi, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 36   :     ATLASSERT(m_hEventDecode);

  00108	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0010b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0010f	75 35		 jne	 SHORT $LN3@WavePlayer
  00111	8b f4		 mov	 esi, esp
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@HAKCMIIN@?$AAm?$AA_?$AAh?$AAE?$AAv?$AAe?$AAn?$AAt?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$AA@
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  0011d	6a 00		 push	 0
  0011f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?1???0WavePlayer@@QAE@XZ@4JA
  00125	83 c1 14	 add	 ecx, 20			; 00000014H
  00128	51		 push	 ecx
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_1JE@KOPMJDFJ@?$AAe?$AA?3?$AA?2?$AAm?$AAy?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAc?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?2?$AAp?$AAc?$AA2?$AA?4?$AA0?$AAt?$AAr?$AAu?$AAn?$AAk?$AA?2?$AAp?$AAc?$AA2?$AA?4@
  0012e	6a 02		 push	 2
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00136	83 c4 18	 add	 esp, 24			; 00000018H
  00139	3b f4		 cmp	 esi, esp
  0013b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00140	83 f8 01	 cmp	 eax, 1
  00143	75 01		 jne	 SHORT $LN3@WavePlayer
  00145	cc		 int	 3
$LN3@WavePlayer:

; 37   : 
; 38   :     m_pDecoder = new AMRFileDecoder();

  00146	6a 40		 push	 64			; 00000040H
  00148	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0014d	83 c4 04	 add	 esp, 4
  00150	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00156	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0015d	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR $T3[ebp], 0
  00164	74 13		 je	 SHORT $LN4@WavePlayer
  00166	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  0016c	e8 00 00 00 00	 call	 ??0AMRFileDecoder@@QAE@XZ ; AMRFileDecoder::AMRFileDecoder
  00171	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv148[ebp], eax
  00177	eb 0a		 jmp	 SHORT $LN5@WavePlayer
$LN4@WavePlayer:
  00179	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv148[ebp], 0
$LN5@WavePlayer:
  00183	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv148[ebp]
  00189	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  0018f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00196	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  0019f	89 51 4c	 mov	 DWORD PTR [ecx+76], edx

; 39   :     ATLASSERT(m_pDecoder);

  001a2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001a5	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  001a9	75 35		 jne	 SHORT $LN6@WavePlayer
  001ab	8b f4		 mov	 esi, esp
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@MHLLCDAC@?$AAm?$AA_?$AAp?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  001b7	6a 00		 push	 0
  001b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?1???0WavePlayer@@QAE@XZ@4JA
  001bf	83 c1 17	 add	 ecx, 23			; 00000017H
  001c2	51		 push	 ecx
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_1JE@KOPMJDFJ@?$AAe?$AA?3?$AA?2?$AAm?$AAy?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAc?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?2?$AAp?$AAc?$AA2?$AA?4?$AA0?$AAt?$AAr?$AAu?$AAn?$AAk?$AA?2?$AAp?$AAc?$AA2?$AA?4@
  001c8	6a 02		 push	 2
  001ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  001d0	83 c4 18	 add	 esp, 24			; 00000018H
  001d3	3b f4		 cmp	 esi, esp
  001d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001da	83 f8 01	 cmp	 eax, 1
  001dd	75 01		 jne	 SHORT $LN6@WavePlayer
  001df	cc		 int	 3
$LN6@WavePlayer:

; 40   : 
; 41   :     // 
; 42   :     InitializeCriticalSection(&m_cs);

  001e0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001e3	83 c0 50	 add	 eax, 80			; 00000050H
  001e6	8b f4		 mov	 esi, esp
  001e8	50		 push	 eax
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
  001ef	3b f4		 cmp	 esi, esp
  001f1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 43   : }

  001f6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001fc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00203	59		 pop	 ecx
  00204	5f		 pop	 edi
  00205	5e		 pop	 esi
  00206	5b		 pop	 ebx
  00207	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  0020d	3b ec		 cmp	 ebp, esp
  0020f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0WavePlayer@@QAE@XZ$0:
  00000	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??0WavePlayer@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0WavePlayer@@QAE@XZ
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0WavePlayer@@QAE@XZ ENDP				; WavePlayer::WavePlayer
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2294 : 		{	// report an out_of_range error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2295 : 		_Xout_of_range("invalid string position");

  00023	8b f4		 mov	 esi, esp
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xran:

; 2296 : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2289 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2290 : 		_Xlength_error("string too long");

  00023	8b f4		 mov	 esi, esp
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xlen:

; 2291 : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Ptr$3 = -20						; size = 4
_this$ = -8						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2273 : 		if (!_Built)

  00023	0f b6 45 08	 movzx	 eax, BYTE PTR __Built$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	75 02		 jne	 SHORT $LN4@Tidy
  0002b	eb 79		 jmp	 SHORT $LN3@Tidy
$LN4@Tidy:

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00034	72 70		 jb	 SHORT $LN3@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	89 4d ec	 mov	 DWORD PTR __Ptr$3[ebp], ecx

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 c0 04	 add	 eax, 4
  00045	50		 push	 eax
  00046	8d 8d 17 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0004c	51		 push	 ecx
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00055	8b c8		 mov	 ecx, eax
  00057	e8 00 00 00 00	 call	 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2279 : 			if (0 < _Newsize)

  0005c	83 7d 0c 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  00060	76 20		 jbe	 SHORT $LN1@Tidy

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);

  00062	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00065	50		 push	 eax
  00066	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$3[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  0006f	83 c4 04	 add	 esp, 4
  00072	50		 push	 eax
  00073	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00076	83 c2 04	 add	 edx, 4
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Tidy:

; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

  00082	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00088	83 c1 01	 add	 ecx, 1
  0008b	51		 push	 ecx
  0008c	8b 55 ec	 mov	 edx, DWORD PTR __Ptr$3[ebp]
  0008f	52		 push	 edx
  00090	8d 85 23 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00096	50		 push	 eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  0009f	8b c8		 mov	 ecx, eax
  000a1	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000a6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 2285 : 		_Eos(_Newsize);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2286 : 		}

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000c5	3b ec		 cmp	 ebp, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00023	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00027	74 20		 je	 SHORT $LN2@Inside
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00031	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  00034	72 13		 jb	 SHORT $LN2@Inside
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  00044	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  00047	77 06		 ja	 SHORT $LN3@Inside
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

  00049	32 c0		 xor	 al, al
  0004b	eb 04		 jmp	 SHORT $LN4@Inside

; 2260 : 		else

  0004d	eb 02		 jmp	 SHORT $LN4@Inside
$LN3@Inside:

; 2261 : 			return (true);

  0004f	b0 01		 mov	 al, 1
$LN4@Inside:

; 2262 : 		}

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -208						; size = 4
tv129 = -208						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2243 : 		if (max_size() < _Newsize)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0002b	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0002e	73 08		 jae	 SHORT $LN6@Grow

; 2244 : 			_Xlen();	// result too long

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2245 : 		if (this->_Myres < _Newsize)

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003e	3b 4d 08	 cmp	 ecx, DWORD PTR __Newsize$[ebp]
  00041	73 15		 jae	 SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00049	51		 push	 ecx
  0004a	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0004d	52		 push	 edx
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00056	eb 53		 jmp	 SHORT $LN4@Grow
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00058	0f b6 45 0c	 movzx	 eax, BYTE PTR __Trim$[ebp]
  0005c	85 c0		 test	 eax, eax
  0005e	74 3b		 je	 SHORT $LN3@Grow
  00060	83 7d 08 10	 cmp	 DWORD PTR __Newsize$[ebp], 16 ; 00000010H
  00064	73 35		 jae	 SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

  00066	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0006c	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  0006f	73 0b		 jae	 SHORT $LN9@Grow
  00071	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00074	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], edx
  0007a	eb 0c		 jmp	 SHORT $LN10@Grow
$LN9@Grow:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00082	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], ecx
$LN10@Grow:
  00088	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv129[ebp]
  0008e	52		 push	 edx
  0008f	6a 01		 push	 1
  00091	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00099	eb 10		 jmp	 SHORT $LN4@Grow
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

  0009b	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0009f	75 0a		 jne	 SHORT $LN4@Grow

; 2251 : 			_Eos(0);	// new size is zero, just null terminate

  000a1	6a 00		 push	 0
  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

  000ab	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  000af	76 0c		 jbe	 SHORT $LN11@Grow
  000b1	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv136[ebp], 1
  000bb	eb 0a		 jmp	 SHORT $LN12@Grow
$LN11@Grow:
  000bd	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
$LN12@Grow:
  000c7	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2253 : 		}

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000d6	3b ec		 cmp	 ebp, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00023	c6 85 2f ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00030	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00033	8d 95 2f ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00039	52		 push	 edx
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00042	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
  0004b	83 c4 08	 add	 esp, 8

; 2238 : 		}

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -288						; size = 4
tv203 = -288						; size = 4
tv204 = -284						; size = 4
tv202 = -284						; size = 4
$T2 = -273						; size = 1
$T3 = -261						; size = 1
$T4 = -249						; size = 1
__Ptr$ = -48						; size = 4
__Newres$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00022	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	59		 pop	 ecx
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00043	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00046	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00049	83 c8 0f	 or	 eax, 15			; 0000000fH
  0004c	89 45 dc	 mov	 DWORD PTR __Newres$[ebp], eax

; 2203 : 		if (max_size() < _Newres)

  0004f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00057	3b 45 dc	 cmp	 eax, DWORD PTR __Newres$[ebp]
  0005a	73 08		 jae	 SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0005f	89 45 dc	 mov	 DWORD PTR __Newres$[ebp], eax
  00062	eb 52		 jmp	 SHORT $LN8@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

  00064	8b 45 dc	 mov	 eax, DWORD PTR __Newres$[ebp]
  00067	33 d2		 xor	 edx, edx
  00069	b9 03 00 00 00	 mov	 ecx, 3
  0006e	f7 f1		 div	 ecx
  00070	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00073	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00076	d1 e9		 shr	 ecx, 1
  00078	3b c8		 cmp	 ecx, eax
  0007a	77 02		 ja	 SHORT $LN7@Copy
  0007c	eb 38		 jmp	 SHORT $LN8@Copy
$LN7@Copy:

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

  0007e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  00084	d1 ee		 shr	 esi, 1
  00086	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0008e	2b c6		 sub	 eax, esi
  00090	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	39 41 18	 cmp	 DWORD PTR [ecx+24], eax
  00096	77 13		 ja	 SHORT $LN5@Copy

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

  00098	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0009e	d1 e9		 shr	 ecx, 1
  000a0	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  000a6	89 4d dc	 mov	 DWORD PTR __Newres$[ebp], ecx

; 2210 : 		else

  000a9	eb 0b		 jmp	 SHORT $LN8@Copy
$LN5@Copy:

; 2211 : 			_Newres = max_size();	// settle for max_size()

  000ab	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  000b3	89 45 dc	 mov	 DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN

  000b6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  000bd	8d 85 ef fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000c3	50		 push	 eax
  000c4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  000cc	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv202[ebp], eax
  000d2	8b 4d dc	 mov	 ecx, DWORD PTR __Newres$[ebp]
  000d5	83 c1 01	 add	 ecx, 1
  000d8	51		 push	 ecx
  000d9	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR tv202[ebp]
  000df	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000e4	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv203[ebp], eax
  000ea	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv203[ebp]
  000f0	89 55 d0	 mov	 DWORD PTR __Ptr$[ebp], edx
  000f3	eb 76		 jmp	 SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2216 : 		_CATCH_ALL

  000f5	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000f8	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000fb	89 45 dc	 mov	 DWORD PTR __Newres$[ebp], eax

; 2218 : 			_TRY_BEGIN

  000fe	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00102	8d 85 fb fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00108	50		 push	 eax
  00109	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00111	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv204[ebp], eax
  00117	8b 4d dc	 mov	 ecx, DWORD PTR __Newres$[ebp]
  0011a	83 c1 01	 add	 ecx, 1
  0011d	51		 push	 ecx
  0011e	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR tv204[ebp]
  00124	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  00129	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv205[ebp], eax
  0012f	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv205[ebp]
  00135	89 55 d0	 mov	 DWORD PTR __Ptr$[ebp], edx
  00138	eb 1b		 jmp	 SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise

  0013a	6a 00		 push	 0
  0013c	6a 01		 push	 1
  0013e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2222 : 			_RERAISE;

  00146	6a 00		 push	 0
  00148	6a 00		 push	 0
  0014a	e8 00 00 00 00	 call	 __CxxThrowException@8

; 2223 : 			_CATCH_END

  0014f	b8 00 00 00 00	 mov	 eax, $LN17@Copy
  00154	c3		 ret	 0
$LN14@Copy:
  00155	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0015c	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
  0015e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2224 : 		_CATCH_END

  00165	b8 00 00 00 00	 mov	 eax, $LN19@Copy
  0016a	c3		 ret	 0
$LN12@Copy:
  0016b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00172	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
  00174	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

  0017b	83 7d 0c 00	 cmp	 DWORD PTR __Oldlen$[ebp], 0
  0017f	76 19		 jbe	 SHORT $LN1@Copy

; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements

  00181	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  00184	50		 push	 eax
  00185	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00188	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0018d	50		 push	 eax
  0018e	8b 4d d0	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00191	51		 push	 ecx
  00192	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00197	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Copy:

; 2229 : 		_Tidy(true);

  0019a	6a 00		 push	 0
  0019c	6a 01		 push	 1
  0019e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

  001a6	8d 45 d0	 lea	 eax, DWORD PTR __Ptr$[ebp]
  001a9	50		 push	 eax
  001aa	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ad	83 c1 04	 add	 ecx, 4
  001b0	51		 push	 ecx
  001b1	8d 95 07 ff ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  001b7	52		 push	 edx
  001b8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  001c0	8b c8		 mov	 ecx, eax
  001c2	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2231 : 		this->_Myres = _Newres;

  001c7	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001ca	8b 4d dc	 mov	 ecx, DWORD PTR __Newres$[ebp]
  001cd	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 2232 : 		_Eos(_Oldlen);

  001d0	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  001d3	50		 push	 eax
  001d4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d7	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2233 : 		}

  001dc	52		 push	 edx
  001dd	8b cd		 mov	 ecx, ebp
  001df	50		 push	 eax
  001e0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@Copy
  001e6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001eb	58		 pop	 eax
  001ec	5a		 pop	 edx
  001ed	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001f0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001f7	59		 pop	 ecx
  001f8	5f		 pop	 edi
  001f9	5e		 pop	 esi
  001fa	5b		 pop	 ebx
  001fb	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  00201	3b ec		 cmp	 ebp, esp
  00203	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c2 08 00	 ret	 8
  0020e	8b ff		 npad	 2
$LN23@Copy:
  00210	01 00 00 00	 DD	 1
  00214	00 00 00 00	 DD	 $LN22@Copy
$LN22@Copy:
  00218	d0 ff ff ff	 DD	 -48			; ffffffd0H
  0021c	04 00 00 00	 DD	 4
  00220	00 00 00 00	 DD	 $LN20@Copy
$LN20@Copy:
  00224	5f		 DB	 95			; 0000005fH
  00225	50		 DB	 80			; 00000050H
  00226	74		 DB	 116			; 00000074H
  00227	72		 DB	 114			; 00000072H
  00228	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a dc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-292]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv75 = -232						; size = 4
$T1 = -221						; size = 1
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1758 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();

  00023	8d 85 23 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
  00039	89 45 ec	 mov	 DWORD PTR __Num$[ebp], eax

; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

  0003c	83 7d ec 01	 cmp	 DWORD PTR __Num$[ebp], 1
  00040	77 0c		 ja	 SHORT $LN3@max_size
  00042	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv75[ebp], 1
  0004c	eb 0c		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR __Num$[ebp]
  00051	83 e8 01	 sub	 eax, 1
  00054	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
$LN4@max_size:
  0005a	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv75[ebp]

; 1761 : 		}

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1753 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1754 : 		return (this->_Mysize);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 1755 : 		}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -32					; size = 4
__Ptr$2 = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00013	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1343 : 		if (this->_Mysize < _Off)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00029	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0002c	73 08		 jae	 SHORT $LN4@erase

; 1344 : 			_Xran();	// _Off off end

  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1345 : 		if (this->_Mysize - _Off <= _Count)

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0003c	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  0003f	3b 4d 0c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00042	77 0e		 ja	 SHORT $LN3@erase

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)

  00044	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00047	50		 push	 eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  00050	eb 46		 jmp	 SHORT $LN2@erase
$LN3@erase:

; 1347 : 		else if (0 < _Count)

  00052	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00056	76 40		 jbe	 SHORT $LN2@erase

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;

  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00060	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00063	89 45 ec	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

  00066	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0006c	2b 4d 0c	 sub	 ecx, DWORD PTR __Count$[ebp]
  0006f	89 4d e0	 mov	 DWORD PTR __Newsize$1[ebp], ecx

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00072	8b 45 e0	 mov	 eax, DWORD PTR __Newsize$1[ebp]
  00075	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  00078	50		 push	 eax
  00079	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$2[ebp]
  0007c	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  0007f	51		 push	 ecx
  00080	8b 55 ec	 mov	 edx, DWORD PTR __Ptr$2[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1352 : 			_Eos(_Newsize);

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Newsize$1[ebp]
  0008f	50		 push	 eax
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1353 : 			}
; 1354 : 		return (*this);

  00098	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1355 : 		}

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1335 : 		if (this->_Mysize < _Off)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00029	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0002c	73 08		 jae	 SHORT $LN1@erase

; 1336 : 			_Xran();	// _Off off end

  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1337 : 		_Eos(_Off);

  00036	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1338 : 		return (*this);

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1339 : 		}

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1168 : 		_DEBUG_POINTER(_Ptr);

  00023	68 90 04 00 00	 push	 1168			; 00000490H
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@OGGFNDFH@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0002d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00039	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  00042	83 c4 04	 add	 esp, 4
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00049	51		 push	 ecx
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1170 : 		}

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)

  00023	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00027	74 16		 je	 SHORT $LN3@assign

; 1151 : 			_DEBUG_POINTER(_Ptr);

  00029	68 7f 04 00 00	 push	 1151			; 0000047fH
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@OGGFNDFH@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00033	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@assign:

; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))

  0003f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  0004b	0f b6 c8	 movzx	 ecx, al
  0004e	85 c9		 test	 ecx, ecx
  00050	74 20		 je	 SHORT $LN2@assign

; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

  00052	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00055	50		 push	 eax
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00061	2b c8		 sub	 ecx, eax
  00063	51		 push	 ecx
  00064	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00067	52		 push	 edx
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00070	eb 3d		 jmp	 SHORT $LN4@assign
$LN2@assign:

; 1157 : 
; 1158 : 		if (_Grow(_Count))

  00072	6a 00		 push	 0
  00074	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00080	0f b6 c8	 movzx	 ecx, al
  00083	85 c9		 test	 ecx, ecx
  00085	74 25		 je	 SHORT $LN1@assign

; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  00087	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0008e	51		 push	 ecx
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1161 : 			_Eos(_Count);

  000a0	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  000a3	50		 push	 eax
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1162 : 			}
; 1163 : 		return (*this);

  000ac	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN4@assign:

; 1164 : 		}

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1130 : 		if (_Right.size() < _Roff)

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00026	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  0002e	73 08		 jae	 SHORT $LN5@assign

; 1131 : 			_Xran();	// _Roff off end

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1132 : 		size_type _Num = _Right.size() - _Roff;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003b	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00040	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  00043	89 45 ec	 mov	 DWORD PTR __Num$[ebp], eax

; 1133 : 		if (_Count < _Num)

  00046	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00049	3b 45 ec	 cmp	 eax, DWORD PTR __Num$[ebp]
  0004c	73 06		 jae	 SHORT $LN4@assign

; 1134 : 			_Num = _Count;	// trim _Num to size

  0004e	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00051	89 45 ec	 mov	 DWORD PTR __Num$[ebp], eax
$LN4@assign:

; 1135 : 
; 1136 : 		if (this == &_Right)

  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  0005a	75 1f		 jne	 SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0005c	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  0005f	03 45 ec	 add	 eax, DWORD PTR __Num$[ebp]
  00062	50		 push	 eax
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0006e	51		 push	 ecx
  0006f	6a 00		 push	 0
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00079	eb 42		 jmp	 SHORT $LN2@assign
$LN3@assign:

; 1138 : 		else if (_Grow(_Num))

  0007b	6a 00		 push	 0
  0007d	8b 45 ec	 mov	 eax, DWORD PTR __Num$[ebp]
  00080	50		 push	 eax
  00081	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00089	0f b6 c8	 movzx	 ecx, al
  0008c	85 c9		 test	 ecx, ecx
  0008e	74 2d		 je	 SHORT $LN2@assign

; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);

  00090	8b 45 ec	 mov	 eax, DWORD PTR __Num$[ebp]
  00093	50		 push	 eax
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00097	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0009c	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1142 : 			_Eos(_Num);

  000b1	8b 45 ec	 mov	 eax, DWORD PTR __Num$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1143 : 			}
; 1144 : 		return (*this);

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1145 : 		}

  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00021	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	8d 8d 23 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00048	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  0004d	50		 push	 eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 781  : 		_Tidy();

  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 782  : 		assign(_Ptr);

  00069	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

  00075	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00089	59		 pop	 ecx
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 684  : 		return (_Alty());

  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 672  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;

  00023	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 675  : 		this->_Orphan_all();

  0002b	8b f4		 mov	 esi, esp
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 676  : 		_Alproxy.destroy(this->_Myproxy);

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	51		 push	 ecx
  00043	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00046	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);

  0004b	6a 01		 push	 1
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00056	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 678  : 		this->_Myproxy = 0;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 679  : 		}

  00064	52		 push	 edx
  00065	8b cd		 mov	 ecx, ebp
  00067	50		 push	 eax
  00068	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Free_proxy
  0006e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00073	58		 pop	 eax
  00074	5a		 pop	 edx
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
  00089	8d 49 00	 npad	 3
$LN5@Free_proxy:
  0008c	01 00 00 00	 DD	 1
  00090	00 00 00 00	 DD	 $LN4@Free_proxy
$LN4@Free_proxy:
  00094	ef ff ff ff	 DD	 -17			; ffffffefH
  00098	01 00 00 00	 DD	 1
  0009c	00 00 00 00	 DD	 $LN3@Free_proxy
$LN3@Free_proxy:
  000a0	5f		 DB	 95			; 0000005fH
  000a1	41		 DB	 65			; 00000041H
  000a2	6c		 DB	 108			; 0000006cH
  000a3	70		 DB	 112			; 00000070H
  000a4	72		 DB	 114			; 00000072H
  000a5	6f		 DB	 111			; 0000006fH
  000a6	78		 DB	 120			; 00000078H
  000a7	79		 DB	 121			; 00000079H
  000a8	00		 DB	 0
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 663  : 		{	// construct proxy from _Alval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;

  00023	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 666  : 		this->_Myproxy = _Alproxy.allocate(1);

  0002b	6a 01		 push	 1
  0002d	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00030	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 01		 mov	 DWORD PTR [ecx], eax

; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

  0003a	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00040	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy
  00045	50		 push	 eax
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0004f	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 668  : 		this->_Myproxy->_Mycont = this;

  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	89 11		 mov	 DWORD PTR [ecx], edx

; 669  : 		}

  0005e	52		 push	 edx
  0005f	8b cd		 mov	 ecx, ebp
  00061	50		 push	 eax
  00062	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Alloc_prox
  00068	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006d	58		 pop	 eax
  0006e	5a		 pop	 edx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	90		 npad	 1
$LN5@Alloc_prox:
  00084	01 00 00 00	 DD	 1
  00088	00 00 00 00	 DD	 $LN4@Alloc_prox
$LN4@Alloc_prox:
  0008c	ef ff ff ff	 DD	 -17			; ffffffefH
  00090	01 00 00 00	 DD	 1
  00094	00 00 00 00	 DD	 $LN3@Alloc_prox
$LN3@Alloc_prox:
  00098	5f		 DB	 95			; 0000005fH
  00099	41		 DB	 65			; 00000041H
  0009a	6c		 DB	 108			; 0000006cH
  0009b	70		 DB	 112			; 00000070H
  0009c	72		 DB	 114			; 00000072H
  0009d	6f		 DB	 111			; 0000006fH
  0009e	78		 DB	 120			; 00000078H
  0009f	79		 DB	 121			; 00000079H
  000a0	00		 DB	 0
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 649  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 650  : 		_Free_proxy();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 651  : 		}

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 643  : 	_String_alloc(const _Alloc& = _Alloc())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();

  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 646  : 		}

  00059	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00060	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00066	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006d	59		 pop	 ecx
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b f4		 mov	 esi, esp
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 517  : 		{	// determine current pointer to buffer for nonmutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0002a	72 17		 jb	 SHORT $LN3@Myptr
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  00038	83 c4 04	 add	 esp, 4
  0003b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00041	eb 0c		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 04	 add	 eax, 4
  00049	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0004f	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]

; 521  : 		}

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 510  : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0002a	72 17		 jb	 SHORT $LN3@Myptr
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  00038	83 c4 04	 add	 esp, 4
  0003b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00041	eb 0c		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 04	 add	 eax, 4
  00049	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0004f	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]

; 514  : 		}

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 492  : 	_String_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b f4		 mov	 esi, esp
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 495  : 		_Myres = 0;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 496  : 		}

  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
  0002c	83 c4 04	 add	 esp, 4

; 885  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 859  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 848  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>

; 802  : 		}

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 734  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 735  : 		return (_Al.max_size());

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00021	e8 00 00 00 00	 call	 ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size

; 736  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00023	83 c8 ff	 or	 eax, -1

; 613  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00023	6a 00		 push	 0
  00025	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  0002e	83 c4 08	 add	 esp, 8

; 579  : 		}

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002c	83 c4 04	 add	 esp, 4

; 574  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	33 c0		 xor	 eax, eax
  00020	88 85 3b ff ff
	ff		 mov	 BYTE PTR $T1[ebp], al
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		{	// construct from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 69   : 		}

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	33 c0		 xor	 eax, eax
  00020	88 85 3b ff ff
	ff		 mov	 BYTE PTR $T1[ebp], al
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 564  : 		_Left = _Right;

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00024	8a 11		 mov	 dl, BYTE PTR [ecx]
  00026	88 10		 mov	 BYTE PTR [eax], dl

; 565  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0001e	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00022	75 0b		 jne	 SHORT $LN3@move
  00024	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00027	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0002d	eb 24		 jmp	 SHORT $LN4@move
$LN3@move:
  0002f	8b f4		 mov	 esi, esp
  00031	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	3b f4		 cmp	 esi, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN4@move:
  00053	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]

; 554  : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0001e	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00022	75 0b		 jne	 SHORT $LN3@copy
  00024	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00027	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0002d	eb 1a		 jmp	 SHORT $LN4@copy
$LN3@copy:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00036	52		 push	 edx
  00037	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _memcpy
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN4@copy:
  00049	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]

; 531  : 		}

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00024	85 c9		 test	 ecx, ecx
  00026	75 0c		 jne	 SHORT $LN3@length
  00028	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00032	eb 12		 jmp	 SHORT $LN4@length
$LN3@length:
  00034	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _strlen
  0003d	83 c4 04	 add	 esp, 4
  00040	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN4@length:
  00046	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]

; 524  : 		}

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT ?ceil@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?ceil@@YAMM@Z PROC					; ceil, COMDAT

; 1048 :         {return (ceilf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	51		 push	 ecx
  0001f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]
  00024	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00029	e8 00 00 00 00	 call	 _ceilf
  0002e	83 c4 04	 add	 esp, 4
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?ceil@@YAMM@Z ENDP					; ceil
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _ceilf
_TEXT	SEGMENT
tv73 = -196						; size = 4
__X$ = 8						; size = 4
_ceilf	PROC						; COMDAT

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 659  :     return (float)ceil(_X);

  0001e	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00023	8b f4		 mov	 esi, esp
  00025	83 ec 08	 sub	 esp, 8
  00028	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ceil
  00033	83 c4 08	 add	 esp, 8
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv73[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv73[ebp]

; 660  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_ceilf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _hypot
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 8
_hypot	PROC						; COMDAT

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 557  :     return _hypot(_X, _Y);

  0001e	8b f4		 mov	 esi, esp
  00020	83 ec 08	 sub	 esp, 8
  00023	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR __Y$[ebp]
  00028	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  00035	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___hypot
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 558  : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_hypot	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00023	e8 00 00 00 00	 call	 ??1CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::~CAtlWinModule
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2821 : __declspec(selectany) CAtlWinModule _AtlWinModule;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00023	e8 00 00 00 00	 call	 ??0CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::CAtlWinModule
  00028	68 00 00 00 00	 push	 OFFSET ??__F_AtlWinModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlWinModule''
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	83 c4 04	 add	 esp, 4
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2805 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2806 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A ; ATL::_AtlBaseModule
  00028	e8 00 00 00 00	 call	 ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
  0002d	50		 push	 eax
  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2807 : 	}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2800 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2801 : 		Term();

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?Term@CAtlWinModule@ATL@@QAEXXZ ; ATL::CAtlWinModule::Term

; 2802 : 	}

  00051	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00058	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CAtlWinModule@ATL@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2786 : 	CAtlWinModule()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2787 : 	{
; 2788 : 		cbSize = sizeof(_ATL_WIN_MODULE);

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 2c 00 00
	00		 mov	 DWORD PTR [eax], 44	; 0000002cH

; 2789 : 		HRESULT hr = AtlWinModuleInit(this);

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
  0003d	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 2790 : 		if (FAILED(hr))

  00040	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00044	7d 44		 jge	 SHORT $LN2@CAtlWinMod

; 2791 : 		{
; 2792 : 			ATLASSERT(0);

  00046	33 c0		 xor	 eax, eax
  00048	75 30		 jne	 SHORT $LN4@CAtlWinMod
  0004a	8b f4		 mov	 esi, esp
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00056	6a 00		 push	 0
  00058	68 e8 0a 00 00	 push	 2792			; 00000ae8H
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_1KA@IOKHNBGA@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00062	6a 02		 push	 2
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0006a	83 c4 18	 add	 esp, 24			; 00000018H
  0006d	3b f4		 cmp	 esi, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	83 f8 01	 cmp	 eax, 1
  00077	75 01		 jne	 SHORT $LN4@CAtlWinMod
  00079	cc		 int	 3
$LN4@CAtlWinMod:

; 2793 : 			CAtlBaseModule::m_bInitFailed = true;

  0007a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2794 : 			cbSize = 0;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN2@CAtlWinMod:

; 2795 : 			return;
; 2796 : 		}
; 2797 : 	}

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00096	3b ec		 cmp	 ebp, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00023	e8 00 00 00 00	 call	 ??1CAtlComModule@ATL@@QAE@XZ ; ATL::CAtlComModule::~CAtlComModule
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT

; 2565 : __declspec(selectany) CAtlComModule _AtlComModule;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00023	e8 00 00 00 00	 call	 ??0CAtlComModule@ATL@@QAE@XZ ; ATL::CAtlComModule::CAtlComModule
  00028	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	83 c4 04	 add	 esp, 4
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_factory$1 = -44					; size = 4
_pCache$2 = -32						; size = 4
_ppEntry$3 = -20					; size = 4
_this$ = -8						; size = 4
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2462 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2463 : 		if (cbSize == 0)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	75 05		 jne	 SHORT $LN6@Term

; 2464 : 			return;

  0002b	e9 88 00 00 00	 jmp	 $LN7@Term
$LN6@Term:

; 2465 : 
; 2466 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00036	89 4d ec	 mov	 DWORD PTR _ppEntry$3[ebp], ecx
  00039	eb 09		 jmp	 SHORT $LN5@Term
$LN4@Term:
  0003b	8b 45 ec	 mov	 eax, DWORD PTR _ppEntry$3[ebp]
  0003e	83 c0 04	 add	 eax, 4
  00041	89 45 ec	 mov	 DWORD PTR _ppEntry$3[ebp], eax
$LN5@Term:
  00044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d ec	 mov	 ecx, DWORD PTR _ppEntry$3[ebp]
  0004a	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0004d	73 55		 jae	 SHORT $LN3@Term

; 2467 : 		{
; 2468 : 			if (*ppEntry != NULL)

  0004f	8b 45 ec	 mov	 eax, DWORD PTR _ppEntry$3[ebp]
  00052	83 38 00	 cmp	 DWORD PTR [eax], 0
  00055	74 4b		 je	 SHORT $LN2@Term

; 2469 : 			{
; 2470 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

  00057	8b 45 ec	 mov	 eax, DWORD PTR _ppEntry$3[ebp]
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0005f	89 55 e0	 mov	 DWORD PTR _pCache$2[ebp], edx

; 2471 : 				
; 2472 : 				if (pCache->pCF != NULL)

  00062	8b 45 e0	 mov	 eax, DWORD PTR _pCache$2[ebp]
  00065	83 38 00	 cmp	 DWORD PTR [eax], 0
  00068	74 38		 je	 SHORT $LN2@Term

; 2473 : 				{
; 2474 : 					// Decode factory pointer if it's not null
; 2475 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  0006a	8b f4		 mov	 esi, esp
  0006c	8b 45 e0	 mov	 eax, DWORD PTR _pCache$2[ebp]
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	51		 push	 ecx
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4
  00078	3b f4		 cmp	 esi, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	89 45 d4	 mov	 DWORD PTR _factory$1[ebp], eax

; 2476 : 					_Analysis_assume_(factory != nullptr);
; 2477 : 					factory->Release();					

  00082	8b 45 d4	 mov	 eax, DWORD PTR _factory$1[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	8b f4		 mov	 esi, esp
  00089	8b 55 d4	 mov	 edx, DWORD PTR _factory$1[ebp]
  0008c	52		 push	 edx
  0008d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00090	ff d0		 call	 eax
  00092	3b f4		 cmp	 esi, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2478 : 					pCache->pCF = NULL;

  00099	8b 45 e0	 mov	 eax, DWORD PTR _pCache$2[ebp]
  0009c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN2@Term:

; 2479 : 				}				
; 2480 : 			}
; 2481 : 		}

  000a2	eb 97		 jmp	 SHORT $LN4@Term
$LN3@Term:

; 2482 : 		m_csObjMap.Term();

  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	83 c1 10	 add	 ecx, 16			; 00000010H
  000aa	e8 00 00 00 00	 call	 ?Term@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Term

; 2483 : 		// Set to 0 to indicate that this function has been called
; 2484 : 		// At this point no one should be concerned about cbsize
; 2485 : 		// having the correct value
; 2486 : 		cbSize = 0;

  000af	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN7@Term:

; 2487 : 	}

  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2456 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlComModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2457 : 		Term();

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?Term@CAtlComModule@ATL@@QAEXXZ ; ATL::CAtlComModule::Term

; 2458 : 	}

  00051	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00058	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CAtlComModule@ATL@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2435 : 	CAtlComModule() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0_ATL_COM_MODULE70@ATL@@QAE@XZ

; 2436 : 	{
; 2437 : 		cbSize = 0;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2438 : 
; 2439 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ___ImageBase

; 2440 : 
; 2441 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c7 40 08 04 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ___pobjMapEntryFirst+4

; 2442 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ___pobjMapEntryLast

; 2443 : 
; 2444 : 		if (FAILED(m_csObjMap.Init()))

  00052	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	83 c1 10	 add	 ecx, 16			; 00000010H
  00058	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  0005d	85 c0		 test	 eax, eax
  0005f	7d 6d		 jge	 SHORT $LN1@CAtlComMod

; 2445 : 		{
; 2446 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));

  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
  00066	6a 00		 push	 0
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
  0006d	e8 00 00 00 00	 call	 ??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ ; ATL::CTraceCategoryEx<2,0>::operator unsigned int
  00072	50		 push	 eax
  00073	68 8e 09 00 00	 push	 2446			; 0000098eH
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@LHJMKFAC@d?3?2program?5files?5?$CIx86?$CJ?2microsoft@
  0007d	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00083	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ; ATL::CTraceFileAndLineInfo::operator()
  0008e	83 c4 10	 add	 esp, 16			; 00000010H

; 2447 : 			ATLASSERT(0);

  00091	33 c0		 xor	 eax, eax
  00093	75 30		 jne	 SHORT $LN4@CAtlComMod
  00095	8b f4		 mov	 esi, esp
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  000a1	6a 00		 push	 0
  000a3	68 8f 09 00 00	 push	 2447			; 0000098fH
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_1KA@IOKHNBGA@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000ad	6a 02		 push	 2
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  000b5	83 c4 18	 add	 esp, 24			; 00000018H
  000b8	3b f4		 cmp	 esi, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	83 f8 01	 cmp	 eax, 1
  000c2	75 01		 jne	 SHORT $LN4@CAtlComMod
  000c4	cc		 int	 3
$LN4@CAtlComMod:

; 2448 : 			CAtlBaseModule::m_bInitFailed = true;

  000c5	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2449 : 			return;

  000cc	eb 09		 jmp	 SHORT $LN2@CAtlComMod
$LN1@CAtlComMod:

; 2450 : 		}
; 2451 : 		// Set cbSize on success.
; 2452 : 		cbSize = sizeof(_ATL_COM_MODULE);

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	c7 00 28 00 00
	00		 mov	 DWORD PTR [eax], 40	; 00000028H
$LN2@CAtlComMod:

; 2453 : 	}

  000d7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx
  000dd	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000e3	3b ec		 cmp	 ebp, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7673 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 7674 : 	if (pWinModule == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pWinModule$[ebp], 0
  00022	75 0a		 jne	 SHORT $LN6@AtlWinModu

; 7675 : 		return E_INVALIDARG;

  00024	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00029	e9 86 00 00 00	 jmp	 $LN7@AtlWinModu
$LN6@AtlWinModu:

; 7676 : 	if (pWinModule->cbSize == 0)

  0002e	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00031	83 38 00	 cmp	 DWORD PTR [eax], 0
  00034	75 04		 jne	 SHORT $LN5@AtlWinModu

; 7677 : 		return S_OK;

  00036	33 c0		 xor	 eax, eax
  00038	eb 7a		 jmp	 SHORT $LN7@AtlWinModu
$LN5@AtlWinModu:

; 7678 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0003a	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  0003d	83 38 2c	 cmp	 DWORD PTR [eax], 44	; 0000002cH
  00040	74 07		 je	 SHORT $LN4@AtlWinModu

; 7679 : 		return E_INVALIDARG;

  00042	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00047	eb 6b		 jmp	 SHORT $LN7@AtlWinModu
$LN4@AtlWinModu:

; 7680 : 
; 7681 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00050	eb 09		 jmp	 SHORT $LN3@AtlWinModu
$LN2@AtlWinModu:
  00052	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00055	83 c0 01	 add	 eax, 1
  00058	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN3@AtlWinModu:
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  0005e	83 c1 20	 add	 ecx, 32			; 00000020H
  00061	e8 00 00 00 00	 call	 ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
  00066	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00069	7d 28		 jge	 SHORT $LN1@AtlWinModu

; 7682 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  0006b	8b f4		 mov	 esi, esp
  0006d	8b 45 0c	 mov	 eax, DWORD PTR _hInst$[ebp]
  00070	50		 push	 eax
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00074	51		 push	 ecx
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00078	83 c1 20	 add	 ecx, 32			; 00000020H
  0007b	e8 00 00 00 00	 call	 ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
  00080	0f b7 10	 movzx	 edx, WORD PTR [eax]
  00083	52		 push	 edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassW@8
  0008a	3b f4		 cmp	 esi, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	eb bf		 jmp	 SHORT $LN2@AtlWinModu
$LN1@AtlWinModu:

; 7683 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

  00093	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00096	83 c1 20	 add	 ecx, 32			; 00000020H
  00099	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 7684 : 	pWinModule->m_csWindowCreate.Term();

  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  000a1	83 c1 04	 add	 ecx, 4
  000a4	e8 00 00 00 00	 call	 ?Term@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Term

; 7685 : 	pWinModule->cbSize = 0;

  000a9	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  000ac	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 7686 : 	return S_OK;

  000b2	33 c0		 xor	 eax, eax
$LN7@AtlWinModu:

; 7687 : }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c2 08 00	 ret	 8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_hr$ = -8						; size = 4
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8417 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 8418 : 	if (pWinModule == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pWinModule$[ebp], 0
  00022	75 0a		 jne	 SHORT $LN3@AtlWinModu

; 8419 : 		return E_INVALIDARG;

  00024	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00029	e9 a0 00 00 00	 jmp	 $LN4@AtlWinModu
$LN3@AtlWinModu:

; 8420 : 
; 8421 : 	// check only in the DLL
; 8422 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0002e	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00031	83 38 2c	 cmp	 DWORD PTR [eax], 44	; 0000002cH
  00034	74 0a		 je	 SHORT $LN2@AtlWinModu

; 8423 : 		return E_INVALIDARG;

  00036	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0003b	e9 8e 00 00 00	 jmp	 $LN4@AtlWinModu
$LN2@AtlWinModu:

; 8424 : 
; 8425 : 	pWinModule->m_pCreateWndList = NULL;

  00040	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00043	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 8426 : 
; 8427 : 	HRESULT hr = pWinModule->m_csWindowCreate.Init();

  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  0004d	83 c1 04	 add	 ecx, 4
  00050	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  00055	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 8428 : 	if (FAILED(hr))

  00058	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005c	7d 6d		 jge	 SHORT $LN1@AtlWinModu

; 8429 : 	{
; 8430 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));

  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
  00063	6a 00		 push	 0
  00065	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
  0006a	e8 00 00 00 00	 call	 ??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ ; ATL::CTraceCategoryEx<32,0>::operator unsigned int
  0006f	50		 push	 eax
  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA
  00075	83 c0 0d	 add	 eax, 13			; 0000000dH
  00078	50		 push	 eax
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@LHJMKFAC@d?3?2program?5files?5?$CIx86?$CJ?2microsoft@
  0007e	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00084	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ; ATL::CTraceFileAndLineInfo::operator()
  0008f	83 c4 10	 add	 esp, 16			; 00000010H

; 8431 : 		ATLASSERT(0);

  00092	33 c0		 xor	 eax, eax
  00094	75 35		 jne	 SHORT $LN1@AtlWinModu
  00096	8b f4		 mov	 esi, esp
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  000a2	6a 00		 push	 0
  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA
  000aa	83 c1 0e	 add	 ecx, 14			; 0000000eH
  000ad	51		 push	 ecx
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_1KA@IOKHNBGA@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000b3	6a 02		 push	 2
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  000bb	83 c4 18	 add	 esp, 24			; 00000018H
  000be	3b f4		 cmp	 esi, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	83 f8 01	 cmp	 eax, 1
  000c8	75 01		 jne	 SHORT $LN1@AtlWinModu
  000ca	cc		 int	 3
$LN1@AtlWinModu:

; 8432 : 	}
; 8433 : 	return hr;

  000cb	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$LN4@AtlWinModu:

; 8434 : }

  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi
  000d0	5b		 pop	 ebx
  000d1	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000d7	3b ec		 cmp	 ebp, esp
  000d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 04 00	 ret	 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 c1 20	 add	 ecx, 32			; 00000020H
  0004f	e8 00 00 00 00	 call	 ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
  00054	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 04	 add	 ecx, 4
  00061	e8 00 00 00 00	 call	 ??1CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::~CComCriticalSection
  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::~CComCriticalSection
__ehhandler$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
  00048	e8 00 00 00 00	 call	 ??0CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::CComCriticalSection
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00054	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	83 c1 20	 add	 ecx, 32			; 00000020H
  0005a	e8 00 00 00 00	 call	 ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::~CComCriticalSection
__ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 230  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 231  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

  00023	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00027	7c 0b		 jl	 SHORT $LN5@operator
  00029	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0002f	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00032	7c 30		 jl	 SHORT $LN6@operator
$LN5@operator:
  00034	8b f4		 mov	 esi, esp
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00040	6a 00		 push	 0
  00042	68 e7 00 00 00	 push	 231			; 000000e7H
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_1KI@FCBEFGEA@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0004c	6a 02		 push	 2
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00054	83 c4 18	 add	 esp, 24			; 00000018H
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 01		 jne	 SHORT $LN6@operator
  00063	cc		 int	 3
$LN6@operator:

; 232  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00064	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00068	7c 0b		 jl	 SHORT $LN1@operator
  0006a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00070	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00073	7c 0c		 jl	 SHORT $LN2@operator
$LN1@operator:

; 233  : 		{
; 234  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00075	6a 01		 push	 1
  00077	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0007c	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN2@operator:

; 235  : 		}
; 236  : 		return m_aT[nIndex];

  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00089	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
$LN4@operator:

; 237  : 	}

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 209  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 210  : 		if(m_aT != NULL)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	74 40		 je	 SHORT $LN4@RemoveAll

; 211  : 		{
; 212  : 			for(int i = 0; i < m_nSize; i++)

  0002b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00032	eb 09		 jmp	 SHORT $LN3@RemoveAll
$LN2@RemoveAll:
  00034	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00037	83 c0 01	 add	 eax, 1
  0003a	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN3@RemoveAll:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  00043	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00046	7d 02		 jge	 SHORT $LN1@RemoveAll

; 213  : 				m_aT[i].~T();

  00048	eb ea		 jmp	 SHORT $LN2@RemoveAll
$LN1@RemoveAll:

; 214  : 			free(m_aT);

  0004a	8b f4		 mov	 esi, esp
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	51		 push	 ecx
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00058	83 c4 04	 add	 esp, 4
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 215  : 			m_aT = NULL;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN4@RemoveAll:

; 216  : 		}
; 217  : 		m_nSize = 0;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 218  : 		m_nAllocSize = 0;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00078	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 219  :     }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 160  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 		return m_nSize;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 162  : 	}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 304  : 	RemoveAll();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 305  : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 120  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 121  : 	}

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 10	 add	 ecx, 16			; 00000010H
  00029	e8 00 00 00 00	 call	 ??1CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::~CComCriticalSection
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 10	 add	 ecx, 16			; 00000010H
  00029	e8 00 00 00 00	 call	 ??0CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::CComCriticalSection
  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 274  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 275  : 		return m_hInst;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 276  : 	}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 139  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 		DeleteCriticalSection(&m_sec);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b f4		 mov	 esi, esp
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 141  : 		return S_OK;

  00036	33 c0		 xor	 eax, eax

; 142  : 	}

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_hRes$ = -20						; size = 4
_this$ = -8						; size = 4
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 128  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 129  : 		HRESULT hRes = S_OK;

  00023	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _hRes$[ebp], 0

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  0002a	6a 00		 push	 0
  0002c	6a 00		 push	 0
  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	85 c0		 test	 eax, eax
  0003c	75 1b		 jne	 SHORT $LN1@Init

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  0003e	8b f4		 mov	 esi, esp
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00046	3b f4		 cmp	 esi, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00053	83 c4 04	 add	 esp, 4
  00056	89 45 ec	 mov	 DWORD PTR _hRes$[ebp], eax
$LN1@Init:

; 133  : 		}
; 134  : 
; 135  : 		return hRes;

  00059	8b 45 ec	 mov	 eax, DWORD PTR _hRes$[ebp]

; 136  : 	}

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 108  : 	CComCriticalSection() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 	{
; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00023	6a 18		 push	 24			; 00000018H
  00025	6a 00		 push	 0
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _memset
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 	}

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 69   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 70   : 	#if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 71   : 		// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);
; 73   : 	#else
; 74   : 		UNREFERENCED_PARAMETER(Flags);
; 75   : 
; 76   : 		// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 77   : 		return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 0c	 mov	 eax, DWORD PTR _dwSpinCount$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _lpCriticalSection$[ebp]
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 78   : 	#endif
; 79   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  0001e	8b f4		 mov	 esi, esp
  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	8b 45 0c	 mov	 eax, DWORD PTR _dwExceptionFlags$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _dwExceptionCode$[ebp]
  0002b	51		 push	 ecx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 32   : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_this$ = 8						; size = 4
_dwCategory$ = 12					; size = 4
_nLevel$ = 16						; size = 4
_pszFmt$ = 20						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ PROC		; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 385  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 386  : 		va_list ptr; va_start(ptr, pszFmt);

  0001e	8d 45 18	 lea	 eax, DWORD PTR _pszFmt$[ebp+4]
  00021	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 387  : 		ATL::CTrace::TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);

  00024	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 14	 mov	 ecx, DWORD PTR _pszFmt$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 10	 mov	 edx, DWORD PTR _nLevel$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 0c	 mov	 eax, DWORD PTR _dwCategory$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003a	52		 push	 edx
  0003b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z ; ATL::CTrace::TraceV
  00046	83 c4 18	 add	 esp, 24			; 00000018H

; 388  : 		va_end(ptr);

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ptr$[ebp], 0

; 389  : 	}

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 361  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _nLineNo$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 362  : 	}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_nBytes$ = -20						; size = 4
_this$ = -8						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 470  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 471  : 		size_t nBytes=0;

  00023	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nBytes$[ebp], 0

; 472  : 		if(FAILED(::ATL::AtlMultiply(&nBytes, nElements, sizeof(T))))

  0002a	6a 02		 push	 2
  0002c	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d ec	 lea	 ecx, DWORD PTR _nBytes$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??$AtlMultiply@I@ATL@@YAJPAIII@Z ; ATL::AtlMultiply<unsigned int>
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	85 c0		 test	 eax, eax
  0003e	7d 04		 jge	 SHORT $LN1@Allocate

; 473  : 		{
; 474  : 			return false;

  00040	32 c0		 xor	 al, al
  00042	eb 0c		 jmp	 SHORT $LN2@Allocate
$LN1@Allocate:

; 475  : 		}
; 476  : 		return AllocateBytes(nBytes);

  00044	8b 45 ec	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00047	50		 push	 eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
$LN2@Allocate:

; 477  : 	}

  00050	52		 push	 edx
  00051	8b cd		 mov	 ecx, ebp
  00053	50		 push	 eax
  00054	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@Allocate
  0005a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0005f	58		 pop	 eax
  00060	5a		 pop	 edx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
  00077	90		 npad	 1
$LN6@Allocate:
  00078	01 00 00 00	 DD	 1
  0007c	00 00 00 00	 DD	 $LN5@Allocate
$LN5@Allocate:
  00080	ec ff ff ff	 DD	 -20			; ffffffecH
  00084	04 00 00 00	 DD	 4
  00088	00 00 00 00	 DD	 $LN4@Allocate
$LN4@Allocate:
  0008c	6e		 DB	 110			; 0000006eH
  0008d	42		 DB	 66			; 00000042H
  0008e	79		 DB	 121			; 00000079H
  0008f	74		 DB	 116			; 00000074H
  00090	65		 DB	 101			; 00000065H
  00091	73		 DB	 115			; 00000073H
  00092	00		 DB	 0
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 449  : 	CHeapPtr() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>

; 450  : 	{
; 451  : 	}

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free, COMDAT
; _this$ = ecx

; 422  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 423  : 		Allocator::Free(m_pData);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  0002e	83 c4 04	 add	 esp, 4

; 424  : 		m_pData = NULL;

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 425  : 	}

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 396  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 397  : 		ATLASSERT(m_pData == NULL);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	74 30		 je	 SHORT $LN4@AllocateBy
  0002b	8b f4		 mov	 esi, esp
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00037	6a 00		 push	 0
  00039	68 8d 01 00 00	 push	 397			; 0000018dH
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@PGLOMAAO@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00043	6a 02		 push	 2
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0004b	83 c4 18	 add	 esp, 24			; 00000018H
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	83 f8 01	 cmp	 eax, 1
  00058	75 01		 jne	 SHORT $LN4@AllocateBy
  0005a	cc		 int	 3
$LN4@AllocateBy:

; 398  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

  0005b	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00064	83 c4 04	 add	 esp, 4
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	89 01		 mov	 DWORD PTR [ecx], eax

; 399  : 		if (m_pData == NULL)

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00072	75 04		 jne	 SHORT $LN1@AllocateBy

; 400  : 			return false;

  00074	32 c0		 xor	 al, al
  00076	eb 02		 jmp	 SHORT $LN2@AllocateBy
$LN1@AllocateBy:

; 401  : 
; 402  : 		return true;

  00078	b0 01		 mov	 al, 1
$LN2@AllocateBy:

; 403  : 	}

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *, COMDAT
; _this$ = ecx

; 378  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 379  : 		return m_pData;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]

; 380  : 	}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 364  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 365  : 		Free();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free

; 366  : 	}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 351  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 352  : 	}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z
_TEXT	SEGMENT
_pszCategory$ = 8					; size = 4
_nCategory$ = 12					; size = 4
?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z PROC		; ATL::CTrace::RegisterCategory, COMDAT

; 300  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 301  : 		if (pszCategory == nullptr)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pszCategory$[ebp], 0
  00022	75 05		 jne	 SHORT $LN2@RegisterCa

; 302  : 		{
; 303  : 			return;

  00024	e9 88 00 00 00	 jmp	 $LN3@RegisterCa
$LN2@RegisterCa:

; 304  : 		}
; 305  : 
; 306  : 		if (m_nLastCategory >= MaxCategoryArray) 

  00029	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 32 ; ATL::CTrace::m_nLastCategory, 00000020H
  00030	72 36		 jb	 SHORT $LN1@RegisterCa

; 307  : 		{
; 308  : 			ATLASSERT(false && "Too many categories defined");

  00032	33 c0		 xor	 eax, eax
  00034	75 30		 jne	 SHORT $LN5@RegisterCa
  00036	8b f4		 mov	 esi, esp
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00042	6a 00		 push	 0
  00044	68 34 01 00 00	 push	 308			; 00000134H
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@IFBFKCIN@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0004e	6a 02		 push	 2
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00056	83 c4 18	 add	 esp, 24			; 00000018H
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	83 f8 01	 cmp	 eax, 1
  00063	75 01		 jne	 SHORT $LN5@RegisterCa
  00065	cc		 int	 3
$LN5@RegisterCa:

; 309  : 			return;

  00066	eb 49		 jmp	 SHORT $LN3@RegisterCa
$LN1@RegisterCa:

; 310  : 		}
; 311  : 
; 312  : 		m_nMap[m_nLastCategory].nCategory = nCategory;

  00068	69 05 00 00 00
	00 04 01 00 00	 imul	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  00072	8b 4d 0c	 mov	 ecx, DWORD PTR _nCategory$[ebp]
  00075	89 88 00 00 00
	00		 mov	 DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[eax], ecx

; 313  : #ifdef _UNICODE
; 314  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, pszCategory);

  0007b	8b f4		 mov	 esi, esp
  0007d	8b 45 08	 mov	 eax, DWORD PTR _pszCategory$[ebp]
  00080	50		 push	 eax
  00081	6a 7f		 push	 127			; 0000007fH
  00083	69 0d 00 00 00
	00 04 01 00 00	 imul	 ecx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  0008d	81 c1 04 00 00
	00		 add	 ecx, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
  00093	51		 push	 ecx
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy_s
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 315  : #else
; 316  : 		wchar_t buffer[MaxLengthOfCategoryName] = { 0 };	
; 317  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%S", pszCategory);
; 318  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, buffer);
; 319  : #endif
; 320  : 	
; 321  : 		m_nLastCategory++;

  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
  000a9	83 c0 01	 add	 eax, 1
  000ac	a3 00 00 00 00	 mov	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, eax ; ATL::CTrace::m_nLastCategory
$LN3@RegisterCa:

; 322  : 	}

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ENDP		; ATL::CTrace::RegisterCategory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
_TEXT	SEGMENT
_wszBuf$ = -32						; size = 4
_cchNeeded$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pwszFmt$ = 24						; size = 4
_args$ = 28						; size = 4
?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00020	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 277  : 		int cchNeeded = _vscwprintf(pwszFmt, args);

  0003d	8b f4		 mov	 esi, esp
  0003f	8b 45 1c	 mov	 eax, DWORD PTR _args$[ebp]
  00042	50		 push	 eax
  00043	8b 4d 18	 mov	 ecx, DWORD PTR _pwszFmt$[ebp]
  00046	51		 push	 ecx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vscwprintf
  0004d	83 c4 08	 add	 esp, 8
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	89 45 ec	 mov	 DWORD PTR _cchNeeded$[ebp], eax

; 278  : 		if (cchNeeded < 0)

  0005a	83 7d ec 00	 cmp	 DWORD PTR _cchNeeded$[ebp], 0
  0005e	7d 05		 jge	 SHORT $LN3@TraceV

; 279  : 		{
; 280  : 			return;

  00060	e9 c3 00 00 00	 jmp	 $LN4@TraceV
$LN3@TraceV:

; 281  : 		}
; 282  : 
; 283  : 		CHeapPtr<wchar_t> wszBuf;

  00065	8d 4d e0	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00068	e8 00 00 00 00	 call	 ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 284  : 		if (!wszBuf.Allocate(cchNeeded + 1))

  00074	8b 45 ec	 mov	 eax, DWORD PTR _cchNeeded$[ebp]
  00077	83 c0 01	 add	 eax, 1
  0007a	50		 push	 eax
  0007b	8d 4d e0	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  0007e	e8 00 00 00 00	 call	 ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
  00083	0f b6 c8	 movzx	 ecx, al
  00086	85 c9		 test	 ecx, ecx
  00088	75 14		 jne	 SHORT $LN2@TraceV

; 285  : 		{
; 286  : 			return;

  0008a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00091	8d 4d e0	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00094	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  00099	e9 8a 00 00 00	 jmp	 $LN4@TraceV
$LN2@TraceV:

; 287  : 		}
; 288  : 
; 289  : 		wszBuf[0] = '\0';

  0009e	8d 4d e0	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000a1	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  000a6	b9 02 00 00 00	 mov	 ecx, 2
  000ab	6b d1 00	 imul	 edx, ecx, 0
  000ae	33 c9		 xor	 ecx, ecx
  000b0	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 290  : 
; 291  : 		if (_vsnwprintf_s(wszBuf, cchNeeded + 1, cchNeeded, pwszFmt, args) == -1)

  000b4	8b f4		 mov	 esi, esp
  000b6	8b 45 1c	 mov	 eax, DWORD PTR _args$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d 18	 mov	 ecx, DWORD PTR _pwszFmt$[ebp]
  000bd	51		 push	 ecx
  000be	8b 55 ec	 mov	 edx, DWORD PTR _cchNeeded$[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 ec	 mov	 eax, DWORD PTR _cchNeeded$[ebp]
  000c5	83 c0 01	 add	 eax, 1
  000c8	50		 push	 eax
  000c9	8d 4d e0	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000cc	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  000d1	50		 push	 eax
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnwprintf_s
  000d8	83 c4 14	 add	 esp, 20			; 00000014H
  000db	3b f4		 cmp	 esi, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e2	83 f8 ff	 cmp	 eax, -1
  000e5	75 11		 jne	 SHORT $LN1@TraceV

; 292  : 		{
; 293  : 			return;

  000e7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ee	8d 4d e0	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000f1	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  000f6	eb 30		 jmp	 SHORT $LN4@TraceV
$LN1@TraceV:

; 294  : 		}
; 295  : 
; 296  : 		TraceV(pszFileName, nLine, dwCategory, nLevel, wszBuf);

  000f8	8d 4d e0	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000fb	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  00100	50		 push	 eax
  00101	8b 45 14	 mov	 eax, DWORD PTR _nLevel$[ebp]
  00104	50		 push	 eax
  00105	8b 4d 10	 mov	 ecx, DWORD PTR _dwCategory$[ebp]
  00108	51		 push	 ecx
  00109	8b 55 0c	 mov	 edx, DWORD PTR _nLine$[ebp]
  0010c	52		 push	 edx
  0010d	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z ; ATL::CTrace::TraceV
  00116	83 c4 14	 add	 esp, 20			; 00000014H

; 297  : 	}

  00119	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00120	8d 4d e0	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00123	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
$LN4@TraceV:
  00128	52		 push	 edx
  00129	8b cd		 mov	 ecx, ebp
  0012b	50		 push	 eax
  0012c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@TraceV
  00132	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00137	58		 pop	 eax
  00138	5a		 pop	 edx
  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0014d	3b ec		 cmp	 ebp, esp
  0014f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
$LN10@TraceV:
  00158	01 00 00 00	 DD	 1
  0015c	00 00 00 00	 DD	 $LN9@TraceV
$LN9@TraceV:
  00160	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00164	04 00 00 00	 DD	 4
  00168	00 00 00 00	 DD	 $LN7@TraceV
$LN7@TraceV:
  0016c	77		 DB	 119			; 00000077H
  0016d	73		 DB	 115			; 00000073H
  0016e	7a		 DB	 122			; 0000007aH
  0016f	42		 DB	 66			; 00000042H
  00170	75		 DB	 117			; 00000075H
  00171	66		 DB	 102			; 00000066H
  00172	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
__ehhandler$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z
_TEXT	SEGMENT
_fileName$ = -2632					; size = 520
_wszBuf$ = -2104					; size = 4
_chCount$ = -2092					; size = 4
_pwszCategoryName$ = -2080				; size = 4
_categoryLength$ = -2068				; size = 4
_wszCategory$ = -2056					; size = 2048
__$ArrayPad$ = -4					; size = 4
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pwszMessage$ = 24					; size = 4
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 149  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 0b 00
	00		 sub	 esp, 2828		; 00000b0cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 f4 ff
	ff		 lea	 edi, DWORD PTR [ebp-2828]
  00012	b9 c3 02 00 00	 mov	 ecx, 707		; 000002c3H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 150  : 		if (CTrace::m_nLevel == CTrace::DisableTracing || CTrace::m_nLevel < nLevel || (CTrace::m_nCategory & dwCategory) == 0)

  00028	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_nLevel@CTrace@ATL@@1IA, -1 ; ATL::CTrace::m_nLevel
  0002f	74 14		 je	 SHORT $LN8@TraceV
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nLevel@CTrace@ATL@@1IA ; ATL::CTrace::m_nLevel
  00036	3b 45 14	 cmp	 eax, DWORD PTR _nLevel$[ebp]
  00039	72 0a		 jb	 SHORT $LN8@TraceV
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nCategory
  00040	23 45 10	 and	 eax, DWORD PTR _dwCategory$[ebp]
  00043	75 05		 jne	 SHORT $LN9@TraceV
$LN8@TraceV:

; 151  : 		{
; 152  : 			return;

  00045	e9 0c 02 00 00	 jmp	 $LN10@TraceV
$LN9@TraceV:

; 153  : 		}
; 154  : 
; 155  : 		wchar_t wszCategory[TraceBufferSize] = {'\0'};

  0004a	33 c0		 xor	 eax, eax
  0004c	66 89 85 f8 f7
	ff ff		 mov	 WORD PTR _wszCategory$[ebp], ax
  00053	68 fe 07 00 00	 push	 2046			; 000007feH
  00058	6a 00		 push	 0
  0005a	8d 85 fa f7 ff
	ff		 lea	 eax, DWORD PTR _wszCategory$[ebp+2]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _memset
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 		int categoryLength = 0;

  00069	c7 85 ec f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _categoryLength$[ebp], 0

; 157  : 		const wchar_t *const pwszCategoryName = GetCategoryName(dwCategory);

  00073	8b 45 10	 mov	 eax, DWORD PTR _dwCategory$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?GetCategoryName@CTrace@ATL@@CAPA_WI@Z ; ATL::CTrace::GetCategoryName
  0007c	83 c4 04	 add	 esp, 4
  0007f	89 85 e0 f7 ff
	ff		 mov	 DWORD PTR _pwszCategoryName$[ebp], eax

; 158  : 		if (pwszCategoryName != nullptr)

  00085	83 bd e0 f7 ff
	ff 00		 cmp	 DWORD PTR _pwszCategoryName$[ebp], 0
  0008c	74 40		 je	 SHORT $LN7@TraceV

; 159  : 		{
; 160  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%s - ", pwszCategoryName)) == -1)

  0008e	8b f4		 mov	 esi, esp
  00090	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _pwszCategoryName$[ebp]
  00096	50		 push	 eax
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@
  0009c	68 00 04 00 00	 push	 1024			; 00000400H
  000a1	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszCategory$[ebp]
  000a7	51		 push	 ecx
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf_s
  000ae	83 c4 10	 add	 esp, 16			; 00000010H
  000b1	3b f4		 cmp	 esi, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _categoryLength$[ebp], eax
  000be	83 bd ec f7 ff
	ff ff		 cmp	 DWORD PTR _categoryLength$[ebp], -1
  000c5	75 05		 jne	 SHORT $LN6@TraceV

; 161  : 			{
; 162  : 				return;

  000c7	e9 8a 01 00 00	 jmp	 $LN10@TraceV
$LN6@TraceV:

; 163  : 			}
; 164  : 		}
; 165  : 		else

  000cc	eb 3b		 jmp	 SHORT $LN5@TraceV
$LN7@TraceV:

; 166  : 		{
; 167  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%u - ", dwCategory)) == -1)

  000ce	8b f4		 mov	 esi, esp
  000d0	8b 45 10	 mov	 eax, DWORD PTR _dwCategory$[ebp]
  000d3	50		 push	 eax
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@
  000d9	68 00 04 00 00	 push	 1024			; 00000400H
  000de	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszCategory$[ebp]
  000e4	51		 push	 ecx
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf_s
  000eb	83 c4 10	 add	 esp, 16			; 00000010H
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _categoryLength$[ebp], eax
  000fb	83 bd ec f7 ff
	ff ff		 cmp	 DWORD PTR _categoryLength$[ebp], -1
  00102	75 05		 jne	 SHORT $LN5@TraceV

; 168  : 			{
; 169  : 				return;

  00104	e9 4d 01 00 00	 jmp	 $LN10@TraceV
$LN5@TraceV:

; 170  : 			}
; 171  : 		}
; 172  : 
; 173  : 		int chCount = (int)wcslen(pwszMessage) + categoryLength + 1;

  00109	8b f4		 mov	 esi, esp
  0010b	8b 45 18	 mov	 eax, DWORD PTR _pwszMessage$[ebp]
  0010e	50		 push	 eax
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  00115	83 c4 04	 add	 esp, 4
  00118	3b f4		 cmp	 esi, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _categoryLength$[ebp]
  00125	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  00129	89 95 d4 f7 ff
	ff		 mov	 DWORD PTR _chCount$[ebp], edx

; 174  : 		CHeapPtr<wchar_t> wszBuf;

  0012f	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00135	e8 00 00 00 00	 call	 ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>

; 175  : 		if (!wszBuf.Allocate(chCount))

  0013a	8b 85 d4 f7 ff
	ff		 mov	 eax, DWORD PTR _chCount$[ebp]
  00140	50		 push	 eax
  00141	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00147	e8 00 00 00 00	 call	 ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
  0014c	0f b6 c8	 movzx	 ecx, al
  0014f	85 c9		 test	 ecx, ecx
  00151	75 10		 jne	 SHORT $LN3@TraceV

; 176  : 		{
; 177  : 			return;

  00153	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00159	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  0015e	e9 f3 00 00 00	 jmp	 $LN10@TraceV
$LN3@TraceV:

; 178  : 		}
; 179  : 
; 180  : 		wszBuf[0] = '\0';

  00163	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00169	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  0016e	b9 02 00 00 00	 mov	 ecx, 2
  00173	6b d1 00	 imul	 edx, ecx, 0
  00176	33 c9		 xor	 ecx, ecx
  00178	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 181  : 
; 182  : 		if (swprintf_s(wszBuf, chCount, L"%s%s", wszCategory, pwszMessage) == -1)

  0017c	8b f4		 mov	 esi, esp
  0017e	8b 45 18	 mov	 eax, DWORD PTR _pwszMessage$[ebp]
  00181	50		 push	 eax
  00182	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszCategory$[ebp]
  00188	51		 push	 ecx
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
  0018e	8b 95 d4 f7 ff
	ff		 mov	 edx, DWORD PTR _chCount$[ebp]
  00194	52		 push	 edx
  00195	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  0019b	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  001a0	50		 push	 eax
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf_s
  001a7	83 c4 14	 add	 esp, 20			; 00000014H
  001aa	3b f4		 cmp	 esi, esp
  001ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b1	83 f8 ff	 cmp	 eax, -1
  001b4	75 10		 jne	 SHORT $LN2@TraceV

; 183  : 		{
; 184  : 			return;

  001b6	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  001bc	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  001c1	e9 90 00 00 00	 jmp	 $LN10@TraceV
$LN2@TraceV:

; 185  : 		}
; 186  : 
; 187  : 		wchar_t fileName[_MAX_PATH] = {'\0'};	

  001c6	33 c0		 xor	 eax, eax
  001c8	66 89 85 b8 f5
	ff ff		 mov	 WORD PTR _fileName$[ebp], ax
  001cf	68 06 02 00 00	 push	 518			; 00000206H
  001d4	6a 00		 push	 0
  001d6	8d 85 ba f5 ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp+2]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 _memset
  001e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 188  : 		if (swprintf_s(fileName, _MAX_PATH, L"%S", pszFileName) == -1)

  001e5	8b f4		 mov	 esi, esp
  001e7	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  001ea	50		 push	 eax
  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@
  001f0	68 04 01 00 00	 push	 260			; 00000104H
  001f5	8d 8d b8 f5 ff
	ff		 lea	 ecx, DWORD PTR _fileName$[ebp]
  001fb	51		 push	 ecx
  001fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf_s
  00202	83 c4 10	 add	 esp, 16			; 00000010H
  00205	3b f4		 cmp	 esi, esp
  00207	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0020c	83 f8 ff	 cmp	 eax, -1
  0020f	75 0d		 jne	 SHORT $LN1@TraceV

; 189  : 		{
; 190  : 			return;

  00211	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00217	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  0021c	eb 38		 jmp	 SHORT $LN10@TraceV
$LN1@TraceV:

; 191  : 		}
; 192  : 
; 193  : 		_CrtDbgReportW(_CRT_WARN, fileName, nLine, nullptr, L"%s", wszBuf);

  0021e	8b f4		 mov	 esi, esp
  00220	8b 85 c8 f7 ff
	ff		 mov	 eax, DWORD PTR _wszBuf$[ebp]
  00226	50		 push	 eax
  00227	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  0022c	6a 00		 push	 0
  0022e	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00231	51		 push	 ecx
  00232	8d 95 b8 f5 ff
	ff		 lea	 edx, DWORD PTR _fileName$[ebp]
  00238	52		 push	 edx
  00239	6a 00		 push	 0
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00241	83 c4 18	 add	 esp, 24			; 00000018H
  00244	3b f4		 cmp	 esi, esp
  00246	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 194  : 	}

  0024b	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00251	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
$LN10@TraceV:
  00256	52		 push	 edx
  00257	8b cd		 mov	 ecx, ebp
  00259	50		 push	 eax
  0025a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@TraceV
  00260	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00265	58		 pop	 eax
  00266	5a		 pop	 edx
  00267	5f		 pop	 edi
  00268	5e		 pop	 esi
  00269	5b		 pop	 ebx
  0026a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026d	33 cd		 xor	 ecx, ebp
  0026f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00274	81 c4 0c 0b 00
	00		 add	 esp, 2828		; 00000b0cH
  0027a	3b ec		 cmp	 ebp, esp
  0027c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00281	8b e5		 mov	 esp, ebp
  00283	5d		 pop	 ebp
  00284	c3		 ret	 0
  00285	8d 49 00	 npad	 3
$LN17@TraceV:
  00288	03 00 00 00	 DD	 3
  0028c	00 00 00 00	 DD	 $LN16@TraceV
$LN16@TraceV:
  00290	f8 f7 ff ff	 DD	 -2056			; fffff7f8H
  00294	00 08 00 00	 DD	 2048			; 00000800H
  00298	00 00 00 00	 DD	 $LN13@TraceV
  0029c	c8 f7 ff ff	 DD	 -2104			; fffff7c8H
  002a0	04 00 00 00	 DD	 4
  002a4	00 00 00 00	 DD	 $LN14@TraceV
  002a8	b8 f5 ff ff	 DD	 -2632			; fffff5b8H
  002ac	08 02 00 00	 DD	 520			; 00000208H
  002b0	00 00 00 00	 DD	 $LN15@TraceV
$LN15@TraceV:
  002b4	66		 DB	 102			; 00000066H
  002b5	69		 DB	 105			; 00000069H
  002b6	6c		 DB	 108			; 0000006cH
  002b7	65		 DB	 101			; 00000065H
  002b8	4e		 DB	 78			; 0000004eH
  002b9	61		 DB	 97			; 00000061H
  002ba	6d		 DB	 109			; 0000006dH
  002bb	65		 DB	 101			; 00000065H
  002bc	00		 DB	 0
$LN14@TraceV:
  002bd	77		 DB	 119			; 00000077H
  002be	73		 DB	 115			; 00000073H
  002bf	7a		 DB	 122			; 0000007aH
  002c0	42		 DB	 66			; 00000042H
  002c1	75		 DB	 117			; 00000075H
  002c2	66		 DB	 102			; 00000066H
  002c3	00		 DB	 0
$LN13@TraceV:
  002c4	77		 DB	 119			; 00000077H
  002c5	73		 DB	 115			; 00000073H
  002c6	7a		 DB	 122			; 0000007aH
  002c7	43		 DB	 67			; 00000043H
  002c8	61		 DB	 97			; 00000061H
  002c9	74		 DB	 116			; 00000074H
  002ca	65		 DB	 101			; 00000065H
  002cb	67		 DB	 103			; 00000067H
  002cc	6f		 DB	 111			; 0000006fH
  002cd	72		 DB	 114			; 00000072H
  002ce	79		 DB	 121			; 00000079H
  002cf	00		 DB	 0
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z ENDP		; ATL::CTrace::TraceV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?GetCategoryName@CTrace@ATL@@CAPA_WI@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_nCategory$ = 8						; size = 4
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z PROC		; ATL::CTrace::GetCategoryName, COMDAT

; 131  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 132  : 		for(unsigned int i = 0; i < m_nLastCategory; i++) 

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@GetCategor
$LN3@GetCategor:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@GetCategor:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00033	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
  00039	73 22		 jae	 SHORT $LN2@GetCategor

; 133  : 		{
; 134  : 			if (m_nMap[i].nCategory == nCategory)

  0003b	69 45 f8 04 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 260
  00042	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[eax]
  00048	3b 4d 08	 cmp	 ecx, DWORD PTR _nCategory$[ebp]
  0004b	75 0e		 jne	 SHORT $LN1@GetCategor

; 135  : 			{
; 136  : 				return m_nMap[i].categryName;

  0004d	69 45 f8 04 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 260
  00054	05 04 00 00 00	 add	 eax, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
  00059	eb 04		 jmp	 SHORT $LN5@GetCategor
$LN1@GetCategor:

; 137  : 			}
; 138  : 		}

  0005b	eb ca		 jmp	 SHORT $LN3@GetCategor
$LN2@GetCategor:

; 139  : 
; 140  : 		return nullptr;

  0005d	33 c0		 xor	 eax, eax
$LN5@GetCategor:

; 141  : 	}

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z ENDP		; ATL::CTrace::GetCategoryName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceISAPI@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceISAPI@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceISAPI'', COMDAT

; 118  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceISAPI> atlTraceISAPI(_T("atlTraceISAPI"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceISAPI@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceISAPI''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 00 40 00	 push	 4194304			; 00400000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSync@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSync@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSync'', COMDAT

; 117  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSync> atlTraceSync(_T("atlTraceSync"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceSync@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSync''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 00 20 00	 push	 2097152			; 00200000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSecurity@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSecurity@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSecurity'', COMDAT

; 116  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSecurity> atlTraceSecurity(_T("atlTraceSecurity"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceSecurity@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSecurity''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 00 10 00	 push	 1048576			; 00100000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceUtil@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceUtil@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceUtil'', COMDAT

; 115  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceUtil> atlTraceUtil(_T("atlTraceUtil"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceUtil@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceUtil''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceMap@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceMap@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceMap'', COMDAT

; 114  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceMap> atlTraceMap(_T("atlTraceMap"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceMap@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceMap''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 00 04 00	 push	 262144			; 00040000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceString@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceString@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceString'', COMDAT

; 113  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceString> atlTraceString(_T("atlTraceString"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceString@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceString''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 00 02 00	 push	 131072			; 00020000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceStencil@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceStencil@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceStencil'', COMDAT

; 112  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceStencil> atlTraceStencil(_T("atlTraceStencil"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceStencil@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceStencil''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 00 01 00	 push	 65536			; 00010000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceCache@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceCache@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceCache'', COMDAT

; 111  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceCache> atlTraceCache(_T("atlTraceCache"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceCache@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceCache''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 80 00 00	 push	 32768			; 00008000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceTime@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceTime@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceTime'', COMDAT

; 110  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceTime> atlTraceTime(_T("atlTraceTime"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceTime@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceTime''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 40 00 00	 push	 16384			; 00004000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceException@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceException@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceException'', COMDAT

; 109  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceException@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceException''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 20 00 00	 push	 8192			; 00002000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceAllocation@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceAllocation@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceAllocation'', COMDAT

; 108  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceAllocation> atlTraceAllocation(_T("atlTraceAllocation"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceAllocation@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceAllocation''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 10 00 00	 push	 4096			; 00001000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceNotImpl@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceNotImpl@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceNotImpl'', COMDAT

; 107  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceNotImpl> atlTraceNotImpl(_T("atlTraceNotImpl"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceNotImpl@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceNotImpl''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 08 00 00	 push	 2048			; 00000800H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSnapin@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSnapin@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSnapin'', COMDAT

; 106  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSnapin> atlTraceSnapin(_T("atlTraceSnapin"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceSnapin@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSnapin''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 04 00 00	 push	 1024			; 00000400H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceDBProvider@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceDBProvider@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceDBProvider'', COMDAT

; 105  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceDBProvider> atlTraceDBProvider(_T("atlTraceDBProvider"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceDBProvider@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceDBProvider''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 02 00 00	 push	 512			; 00000200H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceDBClient@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceDBClient@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceDBClient'', COMDAT

; 104  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceDBClient> atlTraceDBClient(_T("atlTraceDBClient"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceDBClient@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceDBClient''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 01 00 00	 push	 256			; 00000100H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceHosting@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceHosting@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceHosting'', COMDAT

; 103  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceHosting> atlTraceHosting(_T("atlTraceHosting"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceHosting@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceHosting''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 80 00 00 00	 push	 128			; 00000080H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceControls@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceControls@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceControls'', COMDAT

; 102  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceControls> atlTraceControls(_T("atlTraceControls"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceControls@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceControls''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	6a 40		 push	 64			; 00000040H
  00025	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  0002e	83 c4 08	 add	 esp, 8

; 428  : }

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceWindowing@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceWindowing@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceWindowing'', COMDAT

; 101  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceWindowing> atlTraceWindowing(_T("atlTraceWindowing"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceWindowing@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceWindowing''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ PROC	; ATL::CTraceCategoryEx<32,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 78   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : #ifdef _DEBUG
; 80   : 		return traceCategory;

  00023	b8 20 00 00 00	 mov	 eax, 32			; 00000020H

; 81   : #else
; 82   : 		return 0;
; 83   : #endif
; 84   : 	}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ ENDP	; ATL::CTraceCategoryEx<32,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	6a 20		 push	 32			; 00000020H
  00025	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  0002e	83 c4 08	 add	 esp, 8

; 428  : }

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceRefcount@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceRefcount@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceRefcount'', COMDAT

; 100  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceRefcount> atlTraceRefcount(_T("atlTraceRefcount"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceRefcount@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceRefcount''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	6a 10		 push	 16			; 00000010H
  00025	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  0002e	83 c4 08	 add	 esp, 8

; 428  : }

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceRegistrar@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceRegistrar@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceRegistrar'', COMDAT

; 99   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceRegistrar> atlTraceRegistrar(_T("atlTraceRegistrar"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceRegistrar@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceRegistrar''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	6a 08		 push	 8
  00025	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  0002e	83 c4 08	 add	 esp, 8

; 428  : }

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceQI@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceQI@ATL@@YAXXZ PROC				; ATL::`dynamic initializer for 'atlTraceQI'', COMDAT

; 98   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceQI> atlTraceQI(_T("atlTraceQI"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceQI@ATL@@YAXXZ ENDP				; ATL::`dynamic initializer for 'atlTraceQI''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	6a 04		 push	 4
  00025	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  0002e	83 c4 08	 add	 esp, 8

; 428  : }

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceCOM@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceCOM@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceCOM'', COMDAT

; 97   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceCom> atlTraceCOM(_T("atlTraceCOM"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceCOM@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceCOM''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ PROC		; ATL::CTraceCategoryEx<2,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 78   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : #ifdef _DEBUG
; 80   : 		return traceCategory;

  00023	b8 02 00 00 00	 mov	 eax, 2

; 81   : #else
; 82   : 		return 0;
; 83   : #endif
; 84   : 	}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ ENDP		; ATL::CTraceCategoryEx<2,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	6a 02		 push	 2
  00025	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  0002e	83 c4 08	 add	 esp, 8

; 428  : }

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceGeneral@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceGeneral@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceGeneral'', COMDAT

; 96   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceGeneral> atlTraceGeneral(_T("atlTraceGeneral"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceGeneral@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceGeneral''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	6a 01		 push	 1
  00025	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  0002e	83 c4 08	 add	 esp, 8

; 428  : }

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 00 08 00	 push	 524288			; 00080000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC			; ATL::CCRTAllocator::Free, COMDAT

; 281  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 282  : 		free(p);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 283  : 	}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC		; ATL::CCRTAllocator::Allocate, COMDAT

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 277  : 		return malloc(nBytes);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 278  : 	}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_i64Result$ = -12					; size = 8
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00021	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]
  00024	89 45 f4	 mov	 DWORD PTR _i64Result$[ebp], eax
  00027	89 55 f8	 mov	 DWORD PTR _i64Result$[ebp+4], edx

; 152  : 	if(i64Result>UINT_MAX)

  0002a	83 7d f8 00	 cmp	 DWORD PTR _i64Result$[ebp+4], 0
  0002e	77 06		 ja	 SHORT $LN4@AtlMultipl
  00030	83 7d f4 ff	 cmp	 DWORD PTR _i64Result$[ebp], -1
  00034	76 0f		 jbe	 SHORT $LN1@AtlMultipl
$LN4@AtlMultipl:

; 153  : 	{
; 154  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  00036	68 16 02 00 00	 push	 534			; 00000216H
  0003b	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00040	83 c4 04	 add	 esp, 4
  00043	eb 0a		 jmp	 SHORT $LN2@AtlMultipl
$LN1@AtlMultipl:

; 155  : 	}
; 156  : 	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);

  00045	8b 45 f4	 mov	 eax, DWORD PTR _i64Result$[ebp]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 157  : 	return S_OK;

  0004d	33 c0		 xor	 eax, eax
$LN2@AtlMultipl:

; 158  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft sdks\windows\v7.1a\include\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
tv68 = -196						; size = 4
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 23841: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00022	7f 0b		 jg	 SHORT $LN3@HRESULT_FR
  00024	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00027	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  0002d	eb 1b		 jmp	 SHORT $LN4@HRESULT_FR
$LN3@HRESULT_FR:
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	81 c9 00 00 07
	00		 or	 ecx, 458752		; 00070000H
  0003e	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  00044	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv68[ebp], ecx
$LN4@HRESULT_FR:
  0004a	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 105  :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 103  :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
